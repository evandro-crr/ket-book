

<!DOCTYPE html>


<html lang="pt-BR" data-content_root="" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>Algoritmo de Simon &#8212; Computação Quântica com Ket</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" href="../_static/styles/sphinx-book-theme.css?digest=14f4ca6b54d191a8c7657f6c759bf11a5fb86285" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?digest=5a5c038af52cf7bc1a1ec88eea08e6366ee68824"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../_static/translations.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'algoritmos/simon';</script>
    <link rel="index" title="Índice" href="../genindex.html" />
    <link rel="search" title="Buscar" href="../search.html" />
    <link rel="next" title="Referencias" href="../referencias.html" />
    <link rel="prev" title="Algoritmo de Grover" href="grover.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="pt-BR"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../index.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../_static/gcq.svg" class="logo__image only-light" alt="Computação Quântica com Ket - Home"/>
    <script>document.write(`<img src="../_static/gcq.svg" class="logo__image only-dark" alt="Computação Quântica com Ket - Home"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item"><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../index.html">
                    Introdução à Computação Quântica
                </a>
            </li>
        </ul>
        <ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../pytutorial.html">Tutorial de Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="../algebra.html">Álgebra Linear para Computação Quântica</a></li>
<li class="toctree-l1"><a class="reference internal" href="../postulados.html">Postulados da Mecânica Quântica</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kettutorial.html">Programação Quântica com Ket</a></li>
<li class="toctree-l1 current active has-children"><a class="reference internal" href="../algoritmos.html">Algoritmos Quânticos</a><details open="open"><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="grover.html">Algoritmo de Grover</a></li>
<li class="toctree-l2 current active"><a class="current reference internal" href="#">Algoritmo de Simon</a></li>
</ul>
</details></li>
<li class="toctree-l1"><a class="reference external" href="https://qubox.ufsc.br/index.html">Qubox UFSC</a></li>
<li class="toctree-l1"><a class="reference internal" href="../referencias.html">Referencias</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Baixe esta página">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../_sources/algoritmos/simon.md" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Baixar arquivo fonte"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.md</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Imprimir em PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Modo tela cheia"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="Buscar" aria-label="Buscar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<label class="sidebar-toggle secondary-toggle btn btn-sm" for="__secondary"title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</label>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Algoritmo de Simon</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Conteúdo </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#problema-de-simon">Problema de Simon</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id1">Algorítmo de Simon</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#etapas-da-subrotina-de-simon">Etapas da subrotina de Simon</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#probabilidades-nas-medicoes">Probabilidades nas medições</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#encontrando-o-valor-do-periodo-c-exemplo">Encontrando o valor do período c – exemplo</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#encontrando-o-valor-do-periodo-c-caso-geral">Encontrando o valor do período c – caso geral</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#probabilidade-de-erro">Probabilidade de erro</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#algoritmo-classico">Algoritmo Clássico</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#algoritmo-classico-deterministico">Algorítmo clássico determinístico</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#algoritmo-classico-probabilistico">Algoritmo Clássico Probabilístico</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#comparacao-de-desempenho">Comparação de Desempenho</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="algoritmo-de-simon">
<h1>Algoritmo de Simon<a class="headerlink" href="#algoritmo-de-simon" title="Link permanente para este cabeçalho">#</a></h1>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Material extraído do TCC <span class="xref myst"><em>Computação Quântica: Uma abordagem para estudantes de graduação em Ciências Exatas</em></span>, de Giovani Goraiebe Pollachini.</p>
</div>
<p>Assim como no caso do Algoritmo de Deutsch-Jozsa, o Algoritmo de Simon é um algoritmo quântico projetado para resolver o Problema de Simon. Esse problema também tem propósito de funcionar como laboratório de testes para a Computação Quântica, não apresentando aplicações conhecidas.</p>
<section id="problema-de-simon">
<h2>Problema de Simon<a class="headerlink" href="#problema-de-simon" title="Link permanente para este cabeçalho">#</a></h2>
<p>O problema de Simon é um problema de promessa, em que é dada uma função booleana <span class="math notranslate nohighlight">\(f \colon \{ 0,1 \}^n \to  \{ 0,1 \}^n\)</span> que pode ser ou 1-para-1 ou 2-para-1. Esses termos serão definidos e acompanhados de exemplos para melhor entendimento. Em seguida, o enunciado do problema de Simon será escrito formalmente.</p>
<p><strong>Definição 1: Função 1-para-1 e 2-para-1</strong>
Seja <span class="math notranslate nohighlight">\(f \colon \{ 0,1 \}^n \to  \{ 0,1 \}^n\)</span> uma função booleana de <span class="math notranslate nohighlight">\(n\)</span> para <span class="math notranslate nohighlight">\(n\)</span> bits.</p>
<p>A função <span class="math notranslate nohighlight">\(f\)</span> é dita 1-para-1 se é uma bijeção. Nesse caso, isso significa que cada resultado <span class="math notranslate nohighlight">\(y \in  \{ 0,1 \}^n\)</span> é obtido por exatamente uma entrada <span class="math notranslate nohighlight">\(x_1\)</span>, ou seja, <span class="math notranslate nohighlight">\(f(x_1) = y\)</span>. Cada duas entradas distintas <span class="math notranslate nohighlight">\(x_1 \neq x_2\)</span> geram resultados diferentes <span class="math notranslate nohighlight">\(f(x_1) \neq f(x_2)\)</span>.</p>
<p>A função <span class="math notranslate nohighlight">\(f\)</span> é dita 2-para-1 se cada resultado <span class="math notranslate nohighlight">\(y \in  \{ 0,1 \}^n\)</span> é obtido por exatamente duas entradas <span class="math notranslate nohighlight">\(x_1\)</span> e <span class="math notranslate nohighlight">\(x_2\)</span>, isto é, <span class="math notranslate nohighlight">\(f(x_1) = f(x_2) = y\)</span>.</p>
<p>O problema de Simon requer um compromisso para a função booleana de entrada. A propriedade que a função deve satisfazer é chamada, no presente trabalho, de propriedade de Simon.</p>
<p><strong>Definição 2: Propriedade de Simon</strong></p>
<p>Sejam <span class="math notranslate nohighlight">\(f \colon \{ 0,1 \}^n \to  \{ 0,1 \}^n\)</span> uma função booleana de <span class="math notranslate nohighlight">\(n\)</span> para <span class="math notranslate nohighlight">\(n\)</span> bits e <span class="math notranslate nohighlight">\(c \in  \{ 0,1 \}^n\)</span>.</p>
<p>Diz-se que <span class="math notranslate nohighlight">\(f\)</span> satisfaz a propriedade de Simon se</p>
<div class="math notranslate nohighlight">
\[f(x_1) = f(x_2) \Longleftrightarrow x_2 = x_1 \oplus c\]</div>
<p>em que a operação <span class="math notranslate nohighlight">\(\oplus\)</span> é a XOR (ou seja, adição módulo 2) realizada bit a bit nos dois vetores de bits.</p>
<p><strong>Exemplos:</strong></p>
<ul class="simple">
<li><p>A função booleana <span class="math notranslate nohighlight">\(f \colon \{ 0,1 \}^2 \to  \{ 0,1 \}^2\)</span> definida pela tabela abaixo é 1-para-1.</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{array}{c|c}
     x &amp; f(x) \\ \hline 
     00  &amp; 10 \\
     01  &amp; 11 \\
     10  &amp; 00 \\
     11  &amp; 01
    \end{array}\end{split}\]</div>
<ul class="simple">
<li><p>A função booleana <span class="math notranslate nohighlight">\(f \colon \{ 0,1 \}^2 \to  \{ 0,1 \}^2\)</span> definida pela tabela abaixo é 2-para-1.</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{array}{c|c}
     x   &amp; f(x) \\ \hline 
     00  &amp; 10 \\
     01  &amp; 01 \\
     10  &amp; 10 \\
     11  &amp; 01
    \end{array}\end{split}\]</div>
<p>Essa função também satisfaz a propriedade de Simon com <span class="math notranslate nohighlight">\(c = 10\)</span>. De fato,</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{array}{lll}
        10 = 00 \oplus 10 &amp; &amp; f(00) = f(10) = 10  \\
        11 = 01 \oplus 10 &amp; &amp; f(01) = f(11) = 01 \ .
       \end{array} \end{split}\]</div>
<p>Observação 1: Nem toda função booleana 2-para-1 satisfaz a propriedade de Simon. De fato, a função <span class="math notranslate nohighlight">\(f \colon \{ 0,1 \}^3 \to  \{ 0,1 \}^3\)</span> dada por</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{array}{c|cccc|c}
     x    &amp; f(x) &amp; &amp; &amp; x &amp; f(x) \\ -  1-2  - 5-6
     000  &amp; 2 &amp; &amp; &amp; 100  &amp; 2 \\
     001  &amp; 5 &amp; &amp; &amp; 101  &amp; 3 \\
     010  &amp; 1 &amp; &amp; &amp; 110  &amp; 1 \\
     011  &amp; 5 &amp; &amp; &amp; 111  &amp; 3
    \end{array}\end{split}\]</div>
<p>Essa função é 2-para-1. Se satisfizesse a propriedade de Simon, existiria <span class="math notranslate nohighlight">\(c\)</span> satisfazendo <span class="math notranslate nohighlight">\(f(x\oplus c ) = f(x)\)</span> para todo <span class="math notranslate nohighlight">\(x\)</span>. No entanto,</p>
<div class="math notranslate nohighlight">
\[f(000) = f(100), 100 = 000 \oplus 100 \implies c = 100\]</div>
<p>E tem-se que</p>
<div class="math notranslate nohighlight">
\[f(000) = f(100), 100 = 000 \oplus 100 \implies c = 100\]</div>
<p>Essa contradição significa que a propriedade de Simon não é satisfeita.</p>
<p>Observação 2: Se <span class="math notranslate nohighlight">\(f\)</span> satisfaz a propriedade de Simon com <span class="math notranslate nohighlight">\(c=0\ldots0\)</span>, então <span class="math notranslate nohighlight">\(f\)</span> é 1-para-1. E se <span class="math notranslate nohighlight">\(f\)</span> satisfaz a propriedade de Simon com <span class="math notranslate nohighlight">\(c\neq 0\ldots0\)</span>, então <span class="math notranslate nohighlight">\(f\)</span> é 2-para-1.</p>
<p>De posse dessas definições, o problema de Simon tem o seguinte enunciado.</p>
<p><strong>Problema de Simon</strong></p>
<p>Dada uma função booleana <span class="math notranslate nohighlight">\(f\colon \{ 0,1 \}^n \to  \{ 0,1 \}^n\)</span> satisfazendo a propriedade de Simon, distinguir se <span class="math notranslate nohighlight">\(f\)</span> é 1-para-1 ou se é 2-para-1 e encontrar o período <span class="math notranslate nohighlight">\(c\)</span>.</p>
</section>
<section id="id1">
<h2>Algorítmo de Simon<a class="headerlink" href="#id1" title="Link permanente para este cabeçalho">#</a></h2>
<p>O algoritmo a ser apresentado pressupõe que a função booleana <span class="math notranslate nohighlight">\(f\)</span> seja dada como um oráculo XOR. Também são necessários 2 registradores de <span class="math notranslate nohighlight">\(n\)</span> qubits. O algoritmo descreve uma subrotina a ser repetida da ordem de <span class="math notranslate nohighlight">\(n\)</span> vezes. Em cada iteração, obtém-se um pouco de informação, que será processada classicamente para obter como saída o valor de <span class="math notranslate nohighlight">\(c\)</span> e a decisão se <span class="math notranslate nohighlight">\(f\)</span> é 1-para-1 ou 2-para-1.</p>
<p><strong>Procedimento:</strong></p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{array}
   \text{etapa 0:} &amp; \ket{0}\ket{0} &amp; \text{\small{preparação do estado inicial}} \vspace{2pt} \\ 
   \text{etapa 1:} &amp;\displaystyle \tfrac{1}{\sqrt{2^n}} \sum_{x\in\mathbb{B}_n} \ket{x}\ket{0} &amp; \text{\small{$H^{\otimes n}$ no registrador 1}} \vspace{2pt} \\ 
   \text{etapa 2:} &amp;\displaystyle \tfrac{1}{\sqrt{2^n}} \sum_{x\in\mathbb{B}_n} \ket{x}\ket{f(x)} &amp; \text{\small{aplicação de $f$ (oráculo XOR)}} \vspace{2pt} \\ 
   \text{etapa 3:} &amp;\displaystyle \tfrac{1}{2^n} \sum_{x\in\mathbb{B}_n}\sum_{y\in\mathbb{B}_n} \ket{y}\ket{f(x)} &amp; \text{\small{$H^{\otimes n}$ no registrador 1}} \vspace{2pt} \\ 
   \text{etapa 4:} \text{Medição. Obtém informação sobre a resposta} \\ 
   \text{etapa 5:} \text{Repetir etapas 0-4 da ordem de n vezes} \\ 
   \text{etapa 6:} \text{Computar a resposta classicamente com as informações obtidas} 
  \end{array}\end{split}\]</div>
<p><strong>Saída:</strong> Após processamento clássico final, valor do período <span class="math notranslate nohighlight">\(c\)</span> e decisão se <span class="math notranslate nohighlight">\(f\)</span> é 1-para-1 ou 2-para-1.</p>
<p><strong>Circuito</strong></p>
<p>Notação compacta:</p>
<p><img alt="Screenshot 2024-10-22 at 18-39-26 tcc-giovani pdf" src="https://github.com/user-attachments/assets/c73a022d-14cc-43e8-8b37-5af760d98348" /></p>
<p>Notação expandida:</p>
<p><img alt="Screenshot 2024-10-22 at 18-40-22 tcc-giovani pdf" src="https://github.com/user-attachments/assets/28886f3d-3a48-4970-a909-30b4e7ab1306" /></p>
<p><strong>Contas auxiliares</strong></p>
<p><strong>Definição 3:</strong> Usa-se a seguinte notação, com o intuito de simplificar algumas expressões:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{split} 
       \tilde{0} &amp;= +  \\
       \tilde{1} &amp;= - \ . 
       \end{split}\end{split}\]</div>
<p>Dado um vetor de bits <span class="math notranslate nohighlight">\(x \in \mathbb{B}_n\)</span>, escreve-se <span class="math notranslate nohighlight">\(\ket{\tilde{x}} = \ket{\tilde{x}_0 \tilde{x}_1 \ldots \tilde{x}_{n-1} }\)</span> para designar um produto tensorial de estados <span class="math notranslate nohighlight">\(\ket{+}\)</span> e <span class="math notranslate nohighlight">\(\ket{-}\)</span>. Por exemplo,</p>
<div class="math notranslate nohighlight">
\[\ket{x} = \ket{0110} \Longleftrightarrow \ket{\tilde{x}} = \ket{+--+}\]</div>
<p><strong>Definição 4:</strong> <span class="math notranslate nohighlight">\(\mathbb{B}_n\)</span> é o conjunto de todos os vetores de <span class="math notranslate nohighlight">\(n\)</span> bits.</p>
<p><strong>Proposição 1:</strong> Vale que</p>
<div class="math notranslate nohighlight">
\[H^{\otimes n} = \sum_{y \in \mathbb{B}_n} \ket{\tilde{y}}\bra{y}\]</div>
<p><strong>Demonstração:</strong>
Prova-se por indução em <span class="math notranslate nohighlight">\(n\)</span>.</p>
<p>Vale para <span class="math notranslate nohighlight">\(n=1\)</span> qubit, já que <span class="math notranslate nohighlight">\(H\)</span> pode ser escrito como</p>
<div class="math notranslate nohighlight">
\[H = \ket{+}\bra{0} + \ket{-}\bra{1}\]</div>
<p>Vale para <span class="math notranslate nohighlight">\(n=2\)</span> qubits, pois</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{split} 
       H^{\otimes 2} 
       &amp;= H \otimes H \\
       &amp;=  \ket{+}\bra{0} + \ket{-}\bra{1} \otimes \ket{+}\bra{0} + \ket{-}\bra{1}  \\
       &amp;= \ket{++}\bra{00} + \ket{+-}\bra{01} + \ket{-+}\bra{10} + \ket{--}\bra{11} \\
       &amp;= \sum_{y \in \mathbb{B}_2}\ket{\tilde{y}}\bra{y} \ . 
       \end{split}\end{split}\]</div>
<p>Supõe-se, então, que seja válido para <span class="math notranslate nohighlight">\(n\)</span> qubits. Verifica-se o caso <span class="math notranslate nohighlight">\(n+1\)</span>:</p>
<p><img alt="Screenshot 2024-10-22 at 18-43-09 tcc-giovani pdf" src="https://github.com/user-attachments/assets/258c5cd4-b3ca-4c41-bf50-23874f87a522" /></p>
<p>Isso conclui a indução em <span class="math notranslate nohighlight">\(n\)</span>.</p>
<p><strong>Proposição 2:</strong>
Vale que:</p>
<div class="math notranslate nohighlight">
\[\ket{\tilde{x}} = \frac{1}{\sqrt{2^n}} \sum_{y\in\mathbb{B}_n} (-1)^{x\cdot y} \ket{y}\]</div>
<p>em que <span class="math notranslate nohighlight">\(x \cdot y = x_0 y_0 + x_1 y_1 + \ldots + x_{n-1}y_{n-1}\)</span>.</p>
<p>**Demonstração: **
Mostra-se por indução em <span class="math notranslate nohighlight">\(n\)</span>.</p>
<p>Para <span class="math notranslate nohighlight">\(n=1\)</span> qubit, tem-se que</p>
<div class="math notranslate nohighlight">
\[\begin{split}    \begin{split}
        \ket{\tilde{0}} &amp;= \ket{+} = \frac{1}{\sqrt{2}} \big( \ket{0} + \ket{1} \big) \\
        \ket{\tilde{1}} &amp;= \ket{-} = \frac{1}{\sqrt{2}} \big( \ket{0} - \ket{1} \big) \ .
       \end{split}\end{split}\]</div>
<p>Para <span class="math notranslate nohighlight">\(n=2\)</span> qubits, tem-se que</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{split}
     \ket{\tilde{0} \tilde{0} } &amp;= \ket{++} =  \frac{1}{\sqrt{2^2}} \big( \ket{00} + \ket{01} + \ket{10} + \ket{11} \big) \\
     \ket{\tilde{0} \tilde{1} } &amp;= \ket{+-} =  \frac{1}{\sqrt{2^2}} \big( \ket{00} - \ket{01} + \ket{10} - \ket{11}\big) \\ 
     \ket{\tilde{1} \tilde{0} } &amp;= \ket{-+} =  \frac{1}{\sqrt{2^2}} \big( \ket{00} + \ket{01} - \ket{10} - \ket{11} \big) \\ 
     \ket{\tilde{1} \tilde{1} } &amp;= \ket{--} =  \frac{1}{\sqrt{2^2}} \big( \ket{00} - \ket{01} - \ket{10} + \ket{11} \big) \ ,
    \end{split}\end{split}\]</div>
<p>que pode ser resumido em</p>
<div class="math notranslate nohighlight">
\[ \ket{\tilde{x}} = \frac{1}{\sqrt{2^2}} \sum_{y\in\mathbb{B}_n} (-1)^{x\cdot y} \ket{y}\]</div>
<p>Assume-se que o enunciado seja válido para <span class="math notranslate nohighlight">\(n\)</span> qubits. O caso <span class="math notranslate nohighlight">\(n+1\)</span> fica como a seguir.</p>
<div class="math notranslate nohighlight">
\[ \ket{\tilde{x}_0 \tilde{x}_1 \ldots \tilde{x}_{n-1} \tilde{x}_n } = \ket{\tilde{x}_0 \tilde{x}_1 \ldots \tilde{x}_{n-1}} \otimes \ket{\tilde{x}_n }\]</div>
<p>Caso <span class="math notranslate nohighlight">\(\tilde{x}_n = +\)</span>, tem-se</p>
<div class="math notranslate nohighlight">
\[\begin{split} \begin{split}
   &amp;\ket{\tilde{x}_0 \tilde{x}_1 \ldots \tilde{x}_{n-1} + } \\
   \phantom{x}  &amp;= \ket{\tilde{x}_0 \tilde{x}_1 \ldots \tilde{x}_{n-1}} \otimes \ket{+} \\
    &amp;=  \left(\frac{1}{\sqrt{2^n}} \sum_{y\in\mathbb{B}_n} (-1)^{(x_0 \ldots x_{n-1})\cdot y} \ket{y} \right) \otimes \ket{+}  \\
    &amp;=  \frac{1}{\sqrt{2^n}} \sum_{y\in\mathbb{B}_n} (-1)^{(x_0 \ldots x_{n-1})\cdot y} \ket{y_0 \ldots y_{n-1}}  \otimes \frac{1}{\sqrt{2}} \big( \ket{0} + \ket{1} \big) \\
    &amp;=  \frac{1}{\sqrt{2^{n+1}}} \sum_{y\in\mathbb{B}_n} (-1)^{(x_0 \ldots x_{n-1})\cdot y} \big( \underbrace{\ket{y_0 \ldots y_{n-1} 0}}_{y_n = 0} +  \underbrace{\ket{y_0 \ldots y_{n-1} 1}}_{y_n = 1} \big) \\
    &amp;=  \frac{1}{\sqrt{2^{n+1}}} ( \sum_{y\in\mathbb{B}_n} (-1)^{(x_0 \ldots x_{n-1})\cdot y + 0 \cdot 0} \underbrace{\ket{y_0 \ldots y_{n-1} 0}}_{y_n = 0} \ + \\
    &amp; \qquad \qquad \qquad \qquad \qquad +\ (-1)^{(x_0 \ldots x_{n-1})\cdot y + 0 \cdot 1} \underbrace{\ket{y_0 \ldots y_{n-1} 1}}_{y_n = 1} ) \\
    &amp;= \frac{1}{\sqrt{2^{n+1}}} \sum_{y\in\mathbb{B}_{n+1}} (-1)^{(x_0 \ldots x_{n-1}0)\cdot y} \ket{y_0 \ldots y_{n-1} y_n } \ .
   \end{split}\end{split}\]</div>
<p>No caso <span class="math notranslate nohighlight">\(\tilde{x}_n = -\)</span>, tem-se</p>
<div class="math notranslate nohighlight">
\[\begin{split} \begin{split}
   &amp;\ket{\tilde{x}_0 \tilde{x}_1 \ldots \tilde{x}_{n-1} - } \\
   \phantom{x}  &amp;= \ket{\tilde{x}_0 \tilde{x}_1 \ldots \tilde{x}_{n-1}} \otimes \ket{-} \\
    &amp;=  \left(\frac{1}{\sqrt{2^n}} \sum_{y\in\mathbb{B}_n} (-1)^{(x_0 \ldots x_{n-1})\cdot y} \ket{y} \right) \otimes \ket{-}  \\
    &amp;=  \frac{1}{\sqrt{2^n}} \sum_{y\in\mathbb{B}_n} (-1)^{(x_0 \ldots x_{n-1})\cdot y} \ket{y_0 \ldots y_{n-1}}  \otimes \frac{1}{\sqrt{2}} \big( \ket{0} - \ket{1} \big) \\
    &amp;=  \frac{1}{\sqrt{2^{n+1}}} \sum_{y\in\mathbb{B}_n} (-1)^{(x_0 \ldots x_{n-1})\cdot y} \big( \underbrace{\ket{y_0 \ldots y_{n-1} 0}}_{y_n = 0} -  \underbrace{\ket{y_0 \ldots y_{n-1} 1}}_{y_n = 1} \big) \\
    &amp;=  \frac{1}{\sqrt{2^{n+1}}} \sum_{y\in\mathbb{B}_n} (-1)^{(x_0 \ldots x_{n-1})\cdot y + 1 \cdot 0} \underbrace{\ket{y_0 \ldots y_{n-1} 0}}_{y_n = 0} \ + \\
    &amp; \qquad \qquad \qquad \qquad \qquad + \ (-1)^{(x_0 \ldots x_{n-1})\cdot y + 1 \cdot 1} \underbrace{\ket{y_0 \ldots y_{n-1} 1}}_{y_n = 1} \\
    &amp;= \frac{1}{\sqrt{2^{n+1}}} \sum_{y\in\mathbb{B}_{n+1}} (-1)^{(x_0 \ldots x_{n-1}1)\cdot y} \ket{y_0 \ldots y_{n-1} y_n } \ .
   \end{split}\end{split}\]</div>
<p>Isso conclui a demonstração.</p>
<p><strong>Proposição 3:</strong> O produto tensorial de <span class="math notranslate nohighlight">\(n\)</span> operadores de Hadamard é dado por</p>
<div class="math notranslate nohighlight">
\[H^{\otimes n} = \frac{1}{\sqrt{2^n}} \sum_{x,y \in \mathbb{B}_n} (-1)^{x \cdot y} \ket{x}\bra{y}\]</div>
<p><strong>Demonstração:</strong></p>
<p>Usando as proposições do produto tenosrial de H1 e a do produto tensorial entre estados, temos que:</p>
<div class="math notranslate nohighlight">
\[H^{\otimes n} = \sum_{y \in \mathbb{B}_n} \ket{\tilde{y}}\bra{y} = \sum_{y \in \mathbb{B}_n} \frac{1}{\sqrt{2^n}} \sum_{x\in\mathbb{B}_n} (-1)^{x\cdot y}\ket{x}\bra{y} \]</div>
<p><strong>Proposição 4:</strong>
A aplicação de <span class="math notranslate nohighlight">\(H^{\otimes n}\)</span> a um estado <span class="math notranslate nohighlight">\(\ket{x} = \ket{x_{0} x_1 \ldots x_{n-1}}\)</span> na base computacional é dada por</p>
<div class="math notranslate nohighlight">
\[H^{\otimes n} \ket{x} = \frac{1}{\sqrt{2^n}} \sum_{y\in\mathbb{B}_n} (-1)^{x\cdot y} \ket{y}\]</div>
<p>em que <span class="math notranslate nohighlight">\(x \cdot y = x_0 y_0 + x_1 y_1 + \ldots + x_{n-1}y_{n-1}\)</span></p>
<p><strong>Demonstração:</strong>
Usando proposições vistas anteriormente temos que:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{split}
        H^{\otimes n} \ket{x} 
        &amp;= \frac{1}{\sqrt{2^n}} \sum_{y,z\in\mathbb{B}_n} (-1)^{y\cdot z} \ket{y}\bra{z} \ket{x} \\
        &amp;= \frac{1}{\sqrt{2^n}} \sum_{y,z\in\mathbb{B}_n} (-1)^{y\cdot z} \ket{y} \delta_{z,x} \\
        &amp;= \frac{1}{\sqrt{2^n}} \sum_{y \in\mathbb{B}_n} (-1)^{y\cdot x} \ket{y} \ . 
       \end{split}\end{split}\]</div>
<p>Observação: A soma e o produto em</p>
<div class="math notranslate nohighlight">
\[ x \cdot y = x_0 y_0 + x_1 y_1 + \ldots + x_{n-1}y_{n-1} \tag{int}\]</div>
<p>podem ser entendidos como operações com números ou como operações com bits</p>
<div class="math notranslate nohighlight">
\[  x \cdot y = x_0 y_0 \oplus x_1 y_1 \oplus \ldots \oplus x_{n-1}y_{n-1} \tag{bit}\]</div>
<p>em que o produto é dado pela AND e a soma <span class="math notranslate nohighlight">\(\oplus\)</span> é dada pela XOR. Ambas as expressões resultam no mesmo sinal <span class="math notranslate nohighlight">\((-1)^{x\cdot y}\)</span>, pois a expressão (bit) corresponde a (int) módulo 2, visto que a AND se comporta como um produto e a XOR, como uma adição módulo 2.</p>
</section>
<section id="etapas-da-subrotina-de-simon">
<h2>Etapas da subrotina de Simon<a class="headerlink" href="#etapas-da-subrotina-de-simon" title="Link permanente para este cabeçalho">#</a></h2>
<p>As etapas da subrotina quântica são mostradas em detalhes no texto que segue. Inicialmente, aplica-se <span class="math notranslate nohighlight">\(H^{\otimes n}\)</span> ao primeiro registrador, obtendo-se</p>
<div class="math notranslate nohighlight">
\[   \ket{\psi_1} = \frac{1}{\sqrt{2^n}} \sum_{x\in\mathbb{B}_n} \ket{x}\ket{0}\]</div>
<p>em que o primeiro ket engloba <span class="math notranslate nohighlight">\(n\)</span> qubits e representa o primeiro registrador, e o segundo ket contém <span class="math notranslate nohighlight">\(n\)</span> bits e representa o segundo registrador.</p>
<p>A aplicação do oráculo na etapa 2 mantém o primeiro registrador e faz a XOR bit a bit de <span class="math notranslate nohighlight">\(0\)</span> com <span class="math notranslate nohighlight">\(f(x)\)</span>:</p>
<div class="math notranslate nohighlight">
\[\begin{split} \begin{split}
    \ket{\psi_2} 
    &amp;= O_{\text{XOR}} \ket{\psi_1} \\
    &amp;= \frac{1}{\sqrt{2^n}} \sum_{x\in\mathbb{B}_n} O_{\text{XOR}} \ket{x}\ket{0} \\
    &amp;= \frac{1}{\sqrt{2^n}} \sum_{x\in\mathbb{B}_n} \ket{x}\ket{f(x)} \ .
   \end{split}\end{split}\]</div>
<p>Na etapa 3, aplica-se novamente <span class="math notranslate nohighlight">\(H^{\otimes n}\)</span> ao primeiro registrador:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{split} 
    \ket{\psi_3} 
    &amp;= \frac{1}{\sqrt{2^n}} \sum_{x\in\mathbb{B}_n} \big(H^{\otimes n}\ket{x}\big)\ket{f(x)} \\
    &amp;= \frac{1}{\sqrt{2^n}} \sum_{x\in\mathbb{B}_n}\frac{1}{\sqrt{2^n}} \sum_{y\in\mathbb{B}_n} (-1)^{x\cdot y} \ket{y}\ket{f(x)} \\
    &amp;= \frac{1}{2^n} \sum_{x\in\mathbb{B}_n} \sum_{y\in\mathbb{B}_n} (-1)^{x\cdot y} \ket{y}\ket{f(x)} \ . 
   \end{split} \end{split}\]</div>
<p>É conveniente passar o somatório em <span class="math notranslate nohighlight">\(x\)</span> para o segundo registrador, ficando com:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
     \ket{\psi_3} 
     &amp;= \frac{1}{2^n} \sum_{y\in\mathbb{B}_n} \ket{y}\left( \sum_{x\in\mathbb{B}_n} (-1)^{x\cdot y}  \ket{f(x)} \right) \ .
     \end{split}\]</div>
<p>A medida na base computacional, na etapa 4, faz o estado do sistema colapsar em <span class="math notranslate nohighlight">\(\ket{y}\ket{z}\)</span>, com <span class="math notranslate nohighlight">\(z=f(x)\)</span>. Como <span class="math notranslate nohighlight">\(f\)</span> tem a propriedade de Simon, os únicos valores que resultam em <span class="math notranslate nohighlight">\(z\)</span> pela aplicação de <span class="math notranslate nohighlight">\(f\)</span> são</p>
<div class="math notranslate nohighlight">
\[z = f(x_1) = f(x_2) \ , \ \ x_2 = x_1 \oplus c\]</div>
</section>
<section id="probabilidades-nas-medicoes">
<h2>Probabilidades nas medições<a class="headerlink" href="#probabilidades-nas-medicoes" title="Link permanente para este cabeçalho">#</a></h2>
<p>Caso <span class="math notranslate nohighlight">\(c \neq 0\)</span>, o coeficiente multiplicando o estado <span class="math notranslate nohighlight">\(\ket{y}\ket{z}\)</span> em (<span class="math notranslate nohighlight">\(\ast\)</span>) é dado por</p>
<div class="math notranslate nohighlight">
\[\begin{split} \begin{split} 
     a_{y,z}
     &amp;= \frac{1}{2^n} \big( (-1)^{x_1 \cdot y} + (-1)^{x_2 \cdot y} \big) \\
     &amp;= \frac{1}{2^n} \big( (-1)^{x_1 \cdot y} + (-1)^{(x_1 \oplus c) \cdot y} \big) \\
     &amp;= \frac{1}{2^n} \big( (-1)^{x_1 \cdot y} + (-1)^{(x_1 \cdot y) \oplus (c \cdot y)} \big) \\
     &amp;= \frac{1}{2^n} \big( (-1)^{x_1 \cdot y} + (-1)^{x_1 \cdot y} (-1)^{ c \cdot y} \big) \\
     &amp;= \frac{1}{2^n} (-1)^{(x_1 \cdot y)} \big( 1 + (-1)^{ c \cdot y} \big) \\
     &amp;= \begin{cases} 
         0 &amp; \ \ \   c\cdot y = 1 \ , \\
         (-1)^{(x_1 \cdot y)} \frac{2}{2^n} &amp; \ \ \   c \cdot y = 0 \ .
        \end{cases}
     \end{split}\end{split}\]</div>
<p>A probabilidade de se encontrar o sistema no estado <span class="math notranslate nohighlight">\(\ket{y}\ket{z}\)</span> é, então,</p>
<div class="math notranslate nohighlight">
\[\begin{split} \begin{split}
    p_{y,z} 
    &amp;= |a_{y,z}|^2 = \begin{cases} 
       0 &amp; \ \ \  c\cdot y = 1 \\
       \frac{2^2}{2^{2n}} &amp; \ \ \  c \cdot y = 0
      \end{cases}
   \end{split}\end{split}\]</div>
<p>Assim, a medida só fornece vetores de bits <span class="math notranslate nohighlight">\(y\)</span> perpendiculares a <span class="math notranslate nohighlight">\(c\)</span>. A informação que se ganha para encontrar <span class="math notranslate nohighlight">\(c\)</span> é a equação</p>
<div class="math notranslate nohighlight">
\[ c \cdot y = c_1 y_1 \oplus c_1 y_1 \oplus \ldots \oplus c_n y_n = 0\]</div>
<p>Caso <span class="math notranslate nohighlight">\(c = 0\)</span>, o coeficiente em (<span class="math notranslate nohighlight">\(\ast\)</span>) fica apenas</p>
<div class="math notranslate nohighlight">
\[    a_{y,z}
      = \frac{1}{2^n} (-1)^{x_1 \cdot y}\]</div>
<p>e a probabilidade de se encontrar o sistema em <span class="math notranslate nohighlight">\(\ket{y}\ket{z}\)</span> é</p>
<div class="math notranslate nohighlight">
\[     p_{y,z}
     =  |a_{y,z}|^2 = 2^{-2n}\]</div>
<p>Logo, qualquer vetor de bits <span class="math notranslate nohighlight">\(y\)</span> pode sair como resultado da medição.</p>
</section>
<section id="encontrando-o-valor-do-periodo-c-exemplo">
<h2>Encontrando o valor do período c – exemplo<a class="headerlink" href="#encontrando-o-valor-do-periodo-c-exemplo" title="Link permanente para este cabeçalho">#</a></h2>
<p>Primeiramente, apresenta-se o processamento para encontrar o período <span class="math notranslate nohighlight">\(c\)</span> em um exemplo, com o objetivo de facilitar a compreensão do método no caso geral.</p>
<p>Encontrando período <span class="math notranslate nohighlight">\(c\)</span> com o algoritmo de Simon</p>
<p>Seja <span class="math notranslate nohighlight">\(n = 4\)</span> bits. Aplica-se a primeira iteração da subrotina quântica do algoritmo de Simon. Suponha que se obteve o resultado <span class="math notranslate nohighlight">\(y^{(1)} = 0111\)</span>. Esse resultado gera a equação</p>
<div class="math notranslate nohighlight">
\[y^{(1)} \cdot c = 0 \implies c_2 \oplus c_3 \oplus c_4 = 0 \implies c_2 = c_3 \oplus c_4\]</div>
<p>Continua-se aplicando a subrotina até se obter <span class="math notranslate nohighlight">\(n-1 = 3\)</span> equações LI.</p>
<p>A segunda iteração fornece <span class="math notranslate nohighlight">\(y^{(2)} = 1001\)</span>. Esse resultado corresponde à equação</p>
<div class="math notranslate nohighlight">
\[\begin{split}       y^{(2)} \cdot c = 0 \implies c_1 \oplus c_4 = 0  \ 
      \text{e o sistema, após simplificação, fica}
       \begin{cases}
           c_2 = c_3 \oplus c_4 \\
           c_1 = c_4 \ .
         \end{cases}\end{split}\]</div>
<p>Como ainda não são 3 equações LI, continua-se a iteração.</p>
<p>Na terceira iteração, o resultado é <span class="math notranslate nohighlight">\(y^{(3)} = 1110\)</span>. A equação correspondente é</p>
<div class="math notranslate nohighlight">
\[       y^{(3)} \cdot c = 0 \implies c_1 \oplus c_2 \oplus c_3 = 0  \implies c_4 \oplus (c_3 \oplus c_4)\oplus c_3 = 0 \implies 0 = 0\]</div>
<p>e essa equação não fornece informação útil. O sistema continua sendo de 2 equações LI:</p>
<div class="math notranslate nohighlight">
\[\begin{split}        \begin{cases}
           c_2 = c_3 \oplus c_4 \\
           c_1 = c_4 \ .
         \end{cases}\end{split}\]</div>
<p>Na quarta iteração obtém-se <span class="math notranslate nohighlight">\(y^{(4)} = 0001\)</span>, e a equação que esse resultado gera é</p>
<div class="math notranslate nohighlight">
\[\begin{split} y^{(4)} \cdot c = 0 \implies c_4 = 0  
     \text{O sistema fica}
      \begin{cases}
           c_2 = c_3 \\
           c_1 = 0  \\
           c_4 = 0  \ .
         \end{cases}\end{split}\]</div>
<p>Agora são <span class="math notranslate nohighlight">\(3 = n-1\)</span> equações LI. As soluções são <span class="math notranslate nohighlight">\(c' = 0000\)</span> e <span class="math notranslate nohighlight">\(c'' = 0110\)</span>. Poder-se-ia concluir que <span class="math notranslate nohighlight">\(f\)</span> é 2-para-1 com período <span class="math notranslate nohighlight">\(c=0110\)</span>. No entanto, a probabilidade de se estar errado nesse caso é a probabilidade de se obter 4 resultados no mesmo subespaço de dimensão 3, sendo que <span class="math notranslate nohighlight">\(f\)</span> seria 1-para-1 e os <span class="math notranslate nohighlight">\(2^n = 2^4\)</span> resultados seriam equiprováveis:</p>
<div class="math notranslate nohighlight">
\[ \varepsilon_4 \lesssim 1 \cdot 1 \cdot 1 \cdot \frac{2^3}{2^4} = \frac{1}{2}\]</div>
<p>Para reduzir a probabilidade de erro, aplica-se a subrotina novamente. Suponha que obtém-se <span class="math notranslate nohighlight">\(y^{(5)} = 1111\)</span>. Verifica-se se  <span class="math notranslate nohighlight">\(y^{(5)} \perp c''\)</span> ou não. Caso não fosse, concluir-se-ia que haveria mais uma equação independente e o sistema só teria solução <span class="math notranslate nohighlight">\(c'=0\)</span>. Não é esse o caso aqui, pois</p>
<div class="math notranslate nohighlight">
\[ y^{(5)} \cdot c'' = 1111 \cdot 0110 = 0 \oplus 1 \oplus 1 \oplus 0 = 0 \implies y^{(5)} \perp c\]</div>
<p>Poderia concluir-se, nessa etapa, que <span class="math notranslate nohighlight">\(f\)</span> é 2-para-1 com probabilidade de erro igual à probabilidade de se sortear aleatoriamente 5 vetores e todos cairem no mesmo subespaço vetorial de dimensão 3:</p>
<div class="math notranslate nohighlight">
\[\varepsilon_5 \lesssim 1 \cdot 1 \cdot 1 \cdot \frac{2^3}{2^4}\cdot \frac{2^3}{2^4} = \frac{1}{4}\]</div>
<p>Terminando o algoritmo na iteração 5, tem-se que <span class="math notranslate nohighlight">\(f\)</span> é 2-para-1 e que o período é <span class="math notranslate nohighlight">\(c = 0110\)</span>.</p>
<p>A título de curiosidade, a <span class="math notranslate nohighlight">\(f\)</span> utilizada neste exemplo é disposta na tabela abaixo, em que <span class="math notranslate nohighlight">\(A, B, C, D, E, F, G\)</span> e <span class="math notranslate nohighlight">\(H\)</span> denotam 8 palavras distintas de 4 bits.</p>
<div class="math notranslate nohighlight">
\[\begin{split}    \begin{array}{c|cccc|c}
     x    &amp; f(x) &amp; &amp; &amp; x &amp; f(x) \\ 1-2 - 5-6
     0000  &amp; A &amp; &amp; &amp; 1000  &amp; E \\
     0001  &amp; B &amp; &amp; &amp; 1001  &amp; F \\
     0010  &amp; C &amp; &amp; &amp; 1010  &amp; G \\
     0011  &amp; D &amp; &amp; &amp; 1011  &amp; H \\
     0100  &amp; C &amp; &amp; &amp; 1100  &amp; G \\
     0101  &amp; D &amp; &amp; &amp; 1101  &amp; H \\
     0110  &amp; A &amp; &amp; &amp; 1110  &amp; E \\
     0111  &amp; B &amp; &amp; &amp; 1111  &amp; F
    \end{array}\end{split}\]</div>
<p>Repare que, de fato, <span class="math notranslate nohighlight">\(f\)</span> é 2-para-1 com <span class="math notranslate nohighlight">\(c = 0110\)</span>.</p>
</section>
<section id="encontrando-o-valor-do-periodo-c-caso-geral">
<h2>Encontrando o valor do período c – caso geral<a class="headerlink" href="#encontrando-o-valor-do-periodo-c-caso-geral" title="Link permanente para este cabeçalho">#</a></h2>
<p>Repetindo a subrotina <span class="math notranslate nohighlight">\(m\)</span> vezes, obtém-se os resultados <span class="math notranslate nohighlight">\(y^{(1)}, \ldots, y^{(m)}\)</span> das medidas no registrador 1 e o sistema de equações lineares na incógnita <span class="math notranslate nohighlight">\(c = c_1 c_2 \ldots c_n\)</span>:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{cases}
   \ y^{(1)} \cdot c = 0\\
   \ y^{(2)} \cdot c = 0\\
   \ \phantom{y^{(1)} \cdot c} \vdots \\
   \ y^{(m)} \cdot c = 0
  \end{cases} \end{split}\]</div>
<p>Esse sistema sempre admite a solução <span class="math notranslate nohighlight">\(c = 0\)</span>. Supõe-se que se tenha obtido, após a aplicação da subrotina por um número suficiente de vezes, um sistema linear com um número suficiente de equações linearmente independentes (ficará mais claro o que significaria ``suficiente’’ nesse contexto).</p>
<p>Observaçaõ
Para analisar esse sistema, é interessante considerar <span class="math notranslate nohighlight">\(\mathbb{B}_n\)</span> como espaço vetorial sobre os escalares <span class="math notranslate nohighlight">\(\mathbb{B} = \{ 0,1 \}\)</span> e com a soma de vetores dada pela XOR bit a bit <span class="math notranslate nohighlight">\(\oplus\)</span>. É possível verificar que esse espaço satisfaz os axiomas de espaço vetorial. Além disso, é possível imitar o produto interno em <span class="math notranslate nohighlight">\(\mathbb{R}^n\)</span> ou <span class="math notranslate nohighlight">\(\mathbb{C}^n\)</span> com a operação <span class="math notranslate nohighlight">\(r\cdot s = r_1 s_1 \oplus \ldots \oplus r_n s_n\)</span>.</p>
<p>O espaço <span class="math notranslate nohighlight">\(\mathbb{B}_n\)</span> tem dimensão <span class="math notranslate nohighlight">\(n\)</span> e contém <span class="math notranslate nohighlight">\(2^n\)</span> vetores. A maioria dos resultados de Álgebra Linear se mantém para esse caso, exceto que esses espaços vetoriais têm um número finito de vetores e que é possível ter <span class="math notranslate nohighlight">\(x \neq 0\)</span> e <span class="math notranslate nohighlight">\(x \cdot x = 0\)</span>, de forma que o produto <span class="math notranslate nohighlight">\(\cdot\)</span> não é um produto interno em <span class="math notranslate nohighlight">\(\mathbb{B}_n\)</span>. Os subespaços de <span class="math notranslate nohighlight">\(\mathbb{B}_n\)</span> têm dimensão <span class="math notranslate nohighlight">\(2^m, m\leq n\)</span>. O subespaço gerado por <span class="math notranslate nohighlight">\(c \neq 0\)</span> é <span class="math notranslate nohighlight">\(\{0,c\}\)</span> e tem dimensão 1. Se <span class="math notranslate nohighlight">\(W\)</span> é um subespaço, então o conjunto <span class="math notranslate nohighlight">\(W^\perp\)</span> dos vetores perpendiculares a <span class="math notranslate nohighlight">\(W\)</span> é também um subespaço, e vale que <span class="math notranslate nohighlight">\(\dim W + \dim W^\perp = \dim \mathbb{B}_n = n\)</span>.</p>
<p>Os livros de Códigos Corretores de Erros (da Computação Clássica) costumam denotar <span class="math notranslate nohighlight">\(\mathbb{B}\)</span> por <span class="math notranslate nohighlight">\(GF(2)\)</span>, chamado campo de Galois (Galois field) de dois elementos.</p>
<p>Se <span class="math notranslate nohighlight">\(f\)</span> for 1-para-1, espera-se que o sistema admita apenas a solução trivial <span class="math notranslate nohighlight">\(c=0\)</span>. Os valores <span class="math notranslate nohighlight">\(y^{(1)}, \ldots, y^{(m)}\)</span> podem ser quaisquer dos <span class="math notranslate nohighlight">\(2^n\)</span> vetores de bits em <span class="math notranslate nohighlight">\(\mathbb{B}_n\)</span>, por causa da equação (p2). Como a dimensão de <span class="math notranslate nohighlight">\(\mathbb{B}_n\)</span> é <span class="math notranslate nohighlight">\(n\)</span>, há no máximo <span class="math notranslate nohighlight">\(n\)</span> vetores de bits LI nesse espaço. Isso significa que o sistema acima é equivalente a um sistema de <span class="math notranslate nohighlight">\(n\)</span> equações LI, e que só admite a solução trivial <span class="math notranslate nohighlight">\(c=0\)</span>, como esperado.</p>
<p>Por outro lado, se <span class="math notranslate nohighlight">\(f\)</span> for 2-para-1, espera-se que o sistema tenha duas soluções: <span class="math notranslate nohighlight">\(0\)</span> e <span class="math notranslate nohighlight">\(c\neq 0\)</span>. Nesse caso, os valores <span class="math notranslate nohighlight">\(y^{(1)}, \ldots, y^{(m)}\)</span> são, obrigatoriamente, perpendiculares ao vetor <span class="math notranslate nohighlight">\(c\)</span>. Se <span class="math notranslate nohighlight">\(W\)</span> é o subespaço gerado por <span class="math notranslate nohighlight">\(c\)</span>, tem-se que  <span class="math notranslate nohighlight">\(y^{(1)}, \ldots, y^{(m)} \in W^\perp\)</span> e que <span class="math notranslate nohighlight">\(\dim W = 1\)</span> e <span class="math notranslate nohighlight">\(\dim W^\perp = n-1\)</span>, de forma que <span class="math notranslate nohighlight">\(\dim W + \dim W^\perp = \dim \mathbb{B}_n\)</span>. Assim, há no máximo <span class="math notranslate nohighlight">\(n-1\)</span> vetores LI e perpendiculares a <span class="math notranslate nohighlight">\(c\)</span>. O sistema (s) é equivalente a um sistema de <span class="math notranslate nohighlight">\(n-1\)</span> equações LI, e apresenta uma variável livre <span class="math notranslate nohighlight">\(c_j\)</span>, que pode assumir os valores 0 ou 1, gerando as soluções <span class="math notranslate nohighlight">\(0\)</span> e <span class="math notranslate nohighlight">\(c\neq 0\)</span>, como era esperado.</p>
<p>Resumindo, se as <span class="math notranslate nohighlight">\(m\)</span> repetições da subrotina quântica do algoritmo de Simon produzirem um sistema de equações com o máximo possível de equações LI, a solução do sistema fornecerá <span class="math notranslate nohighlight">\(c\)</span> e, dependendo se há apenas a solução nula ou se, além dessa, há uma solução <span class="math notranslate nohighlight">\(c \neq 0\)</span>, pode-se distinguir os casos `<span class="math notranslate nohighlight">\(f\)</span> é 1-para-1’ ou ``<span class="math notranslate nohighlight">\(f\)</span> é 2-para-1’’. O número de repetições <span class="math notranslate nohighlight">\(m\)</span> requerido é proporcional a <span class="math notranslate nohighlight">\(n\)</span>.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Na primeira iteração, o número de vetores que acrescentam informação é <span class="math notranslate nohighlight">\(2^n - 1\)</span> dentre os <span class="math notranslate nohighlight">\(2^n\)</span> possíveis (apenas o vetor nulo seria útil). Após obter um vetor não nulo, a próxima iteração tem a chance de <span class="math notranslate nohighlight">\(2^{n-1} - 1\)</span> entre <span class="math notranslate nohighlight">\(2^n\)</span> de resultar num vetor que seja LI com o anterior.</p>
</div>
</section>
<section id="probabilidade-de-erro">
<h2>Probabilidade de erro<a class="headerlink" href="#probabilidade-de-erro" title="Link permanente para este cabeçalho">#</a></h2>
<p>Em relação à probabilidade de erro no caso geral, tem-se o seguinte. A partir de um número de iterações suficientemente grande (da ordem de <span class="math notranslate nohighlight">\(n\)</span>), a cada nova iteração, ou se descobre que <span class="math notranslate nohighlight">\(f\)</span> é 1-para-1 (resultado cada vez mais improvável) ou se escolhe que <span class="math notranslate nohighlight">\(f\)</span> é 2-para-1 com probabilidade de erro:</p>
<div class="math notranslate nohighlight">
\[\varepsilon_m \lesssim \underbrace{1  \ldots  1}_{n-1 \text{ vezes}} \cdot \underbrace{ \frac{2^{n-1}}{2^n} \ldots \frac{2^{n-1}}{2^n}}_{m-(n-1) \text{ vezes}} = \frac{1}{2^{m-n+1}}\]</div>
<p>Essa estimativa não é exata, pois está considerando o caso em que <span class="math notranslate nohighlight">\(n-1\)</span> resultados forneceram vetores de bits não-nulos e LI, e os outros resultados cairam no subespaço gerado pelos <span class="math notranslate nohighlight">\(n-1\)</span> vetores LI. Poderia ter acontecido de se obter menos vetores LI e os outros cairem no subespaço gerado por eles, apesar de parecer menos provável. Essa estimativa, contudo, serve para dar uma pista quanto à quantidade de iterações do algoritmo quântico. Dessa forma, se o número de iterações <span class="math notranslate nohighlight">\(m\)</span> for da ordem de <span class="math notranslate nohighlight">\(n\)</span>, a probabilidade de erro pode ser feita menor que <span class="math notranslate nohighlight">\(1/2\)</span>.</p>
</section>
<section id="algoritmo-classico">
<h2>Algoritmo Clássico<a class="headerlink" href="#algoritmo-classico" title="Link permanente para este cabeçalho">#</a></h2>
<section id="algoritmo-classico-deterministico">
<h3>Algorítmo clássico determinístico<a class="headerlink" href="#algoritmo-classico-deterministico" title="Link permanente para este cabeçalho">#</a></h3>
<p>Um algoritmo clássico para o Problema de Simon consiste em escolher entradas <span class="math notranslate nohighlight">\(x\)</span> em <span class="math notranslate nohighlight">\(\mathbb{B}_n\)</span>, calcular <span class="math notranslate nohighlight">\(f(x)\)</span> e comparar com os outros valores já obtidos, até que se encontre um par de vetores distintos <span class="math notranslate nohighlight">\(x_{(1)}\)</span> e <span class="math notranslate nohighlight">\(x_{(2)}\)</span> com <span class="math notranslate nohighlight">\(f(x_{(1)}) = f(x_{(2)})\)</span> ou até que se possa concluir que <span class="math notranslate nohighlight">\(f\)</span> é 1-para-1.</p>
<p>Supondo que seja possível armazenar todas as entradas testadas e seus resultados pela aplicação da <span class="math notranslate nohighlight">\(f\)</span>, na pior das hipóteses, deve-se calcular <span class="math notranslate nohighlight">\(f\)</span> para metade das entradas mais uma, isto é, <span class="math notranslate nohighlight">\(2^{n}/2 + 1\)</span> vezes. Caso <span class="math notranslate nohighlight">\(f\)</span> seja 1-para-1, todos os resultados seriam distintos, e caso <span class="math notranslate nohighlight">\(f\)</span> seja 2-para-1, na pior das hipóteses, na tentativa de número <span class="math notranslate nohighlight">\(2^{n}/2 + 1\)</span> será obtido um valor repetido após aplicação da função.</p>
</section>
<section id="algoritmo-classico-probabilistico">
<h3>Algoritmo Clássico Probabilístico<a class="headerlink" href="#algoritmo-classico-probabilistico" title="Link permanente para este cabeçalho">#</a></h3>
<p>Para melhorar o desempenho do algoritmo determinístico acima, pode-se relaxar o desempenho, permitindo-se uma probabilidade de erro <span class="math notranslate nohighlight">\(\varepsilon\)</span> na escolha. Sorteia-se aleatoriamente <span class="math notranslate nohighlight">\(x\)</span> dentre o conjunto de entradas não testadas ainda, calcula-se <span class="math notranslate nohighlight">\(f(x)\)</span> e compara-se o valor obtido com o fornecido pelas entradas já testadas. Repete-se por um número suficiente de tentativas ou até algum par ser encontrado; se nenhum par foi encontrado, decide-se por `<span class="math notranslate nohighlight">\(f\)</span> é 1-para-1’ e se for encontrado, decide-se por ``<span class="math notranslate nohighlight">\(f\)</span> é 2-para-1’’ e utiliza-se o par <span class="math notranslate nohighlight">\(x_{(1)}, x_{(2)}\)</span> encontrado para calcular <span class="math notranslate nohighlight">\(c = x_{(1)}\oplus x_{(2)}\)</span>.</p>
<p>Após <span class="math notranslate nohighlight">\(m\)</span> iterações, o número de pares já testados é <span class="math notranslate nohighlight">\(N_{\text{ob}}\)</span>, em que</p>
<div class="math notranslate nohighlight">
\[N_{\text{ob}} = \binom{m}{2} = \frac{m(m-1)}{2}\]</div>
<p>isto é, o número de pares que se pode formar dentre <span class="math notranslate nohighlight">\(m\)</span> elementos distintos sem importar a ordem em que se encontram no par.</p>
<p>Caso <span class="math notranslate nohighlight">\(f\)</span> seja 2-para-1, o número de pares desejado (ou seja, que resultam no mesmo valor após aplicação de <span class="math notranslate nohighlight">\(f\)</span>) é <span class="math notranslate nohighlight">\(N_{\text{des}}\)</span> dado por</p>
<div class="math notranslate nohighlight">
\[N_{\text{des}} = \frac{2^n}{2}\]</div>
<p>A probabilidade de pelo menos um par desejado ter sido obtido após <span class="math notranslate nohighlight">\(k\)</span> iterações é</p>
<div class="math notranslate nohighlight">
\[p_m = \frac{N_{\text{ob}}}{N_{\text{des}}} = \frac{m(m-1)}{2^n}\]</div>
<p>Caso nenhum par desejado tenha sido encontrado, opta-se por ``<span class="math notranslate nohighlight">\(f\)</span> é 1-para-1’’ com probabilidade de erro dada por</p>
<div class="math notranslate nohighlight">
\[\varepsilon_m = 1 - p_m = 1 - \frac{m(m-1)}{2^n}\]</div>
<p>Para que a probabilidade de erro seja <span class="math notranslate nohighlight">\(\varepsilon &lt; 1/2\)</span>, deve-se ter</p>
<div class="math notranslate nohighlight">
\[\varepsilon_m &lt; \frac{1}{2} \implies  \frac{m(m-1)}{2^n} &gt; \frac{1}{2} \implies m^2 - m - 2^{n-1} &gt; 0\]</div>
<p>Resolvendo para <span class="math notranslate nohighlight">\(m &gt; 0\)</span>, deve-se ter</p>
<div class="math notranslate nohighlight">
\[m &gt; \frac{1 + \sqrt{1 + 2^{n+1}}}{2}\]</div>
<p>logo <span class="math notranslate nohighlight">\(m\)</span> deve ser da ordem de <span class="math notranslate nohighlight">\(2^{n/2}\)</span> iterações.</p>
</section>
</section>
<section id="comparacao-de-desempenho">
<h2>Comparação de Desempenho<a class="headerlink" href="#comparacao-de-desempenho" title="Link permanente para este cabeçalho">#</a></h2>
<p>O desempenho dos algoritmos clássico determinístico, clássico probabilístico e quântico são resumidos na tabela abaixo.</p>
<p><img alt="Screenshot 2024-10-22 at 18-43-52 tcc-giovani pdf" src="https://github.com/user-attachments/assets/14e9865f-639c-4561-b967-053d35203acc" /></p>
<p>Da mesma forma como no problema de Deutsch-Jozsa, essa comparação tem limitações, mas serve como laboratório para testar em que situações a Computação Quântica pode trazer vantagem computacional em relação à Computação Clássica. Em particular, esse é um exemplo em que o algoritmo quântico apresenta ganho exponencial em desempenho em relação aos algoritmos clássicos existentes.</p>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "evandro-crr/ket-book",
            ref: "main",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./algoritmos"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="grover.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">anterior</p>
        <p class="prev-next-title">Algoritmo de Grover</p>
      </div>
    </a>
    <a class="right-next"
       href="../referencias.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">próximo</p>
        <p class="prev-next-title">Referencias</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Conteúdo
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#problema-de-simon">Problema de Simon</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id1">Algorítmo de Simon</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#etapas-da-subrotina-de-simon">Etapas da subrotina de Simon</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#probabilidades-nas-medicoes">Probabilidades nas medições</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#encontrando-o-valor-do-periodo-c-exemplo">Encontrando o valor do período c – exemplo</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#encontrando-o-valor-do-periodo-c-caso-geral">Encontrando o valor do período c – caso geral</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#probabilidade-de-erro">Probabilidade de erro</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#algoritmo-classico">Algoritmo Clássico</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#algoritmo-classico-deterministico">Algorítmo clássico determinístico</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#algoritmo-classico-probabilistico">Algoritmo Clássico Probabilístico</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#comparacao-de-desempenho">Comparação de Desempenho</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
De Evandro Chagas Ribeiro da Rosa
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2024.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>