
<!DOCTYPE html>


<html lang="pt-BR" data-content_root="./" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Programacão Quântica com Ket &#8212; Computação Quântica com Ket</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="_static/styles/sphinx-book-theme.css?v=eba8b062" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.8ecb98da25f57f5357bf6f572d296f466b2cfe2517ffebfabe82451661e28f02.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css?v=4fa983c6" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-design.min.css?v=95c83b7e" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="_static/documentation_options.js?v=2efa9f5e"></script>
    <script src="_static/doctools.js?v=9a2dae69"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="_static/copybutton.js?v=f281be69"></script>
    <script src="_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="_static/togglebutton.js?v=4a39c7ea"></script>
    <script src="_static/translations.js?v=daa5921a"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="_static/design-tabs.js?v=f930bc37"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="_static/sphinx-thebe.js?v=c100c467"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '08-kettutorial';</script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <link rel="index" title="Índice" href="genindex.html" />
    <link rel="search" title="Buscar" href="search.html" />
    <link rel="next" title="Algoritmos Quânticos" href="09-algoritmos.html" />
    <link rel="prev" title="Computação Quântica" href="07-computacao_quantica.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="pt-BR"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="01-index.html">
  
  
  
  
  
    
    
      
    
    
    <img src="_static/gcq.svg" class="logo__image only-light" alt="Computação Quântica com Ket - Home"/>
    <script>document.write(`<img src="_static/gcq.svg" class="logo__image only-dark" alt="Computação Quântica com Ket - Home"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Buscar" aria-label="Buscar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Buscar</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="01-index.html">
                    Introdução à Computação Quântica
                </a>
            </li>
        </ul>
        <ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="02-pytutorial.html">Tutorial de Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="03-complexos.html">Números Complexos para Computação Quântica</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="04-algebra.html">Álgebra Linear para Computação Quântica</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="algebra/04_1-basicos.html">Conceitos Básicos de Álgebra</a></li>
<li class="toctree-l2"><a class="reference internal" href="algebra/04_2-transformacoes.html">Transformações Lineares</a></li>
<li class="toctree-l2"><a class="reference internal" href="algebra/04_3-operadores.html">Autovalores, Autovetores e Operadores</a></li>
<li class="toctree-l2"><a class="reference internal" href="algebra/04_4-prod_tensorial.html">Produto Tensorial</a></li>
</ul>
</details></li>
<li class="toctree-l1"><a class="reference internal" href="05-postulados.html">Postulados da Mecânica Quântica</a></li>
<li class="toctree-l1"><a class="reference internal" href="06-computacao_classica.html">Computação Clássica</a></li>
<li class="toctree-l1"><a class="reference internal" href="07-computacao_quantica.html">Computação Quântica</a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#">Programacão Quântica com Ket</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="09-algoritmos.html">Algoritmos Quânticos</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="algoritmos/09_1-grover.html">Algoritmo de Busca de Grover</a></li>
<li class="toctree-l2"><a class="reference internal" href="algoritmos/09_2-deutsch-jozsa.html">Problema de Deutsch-Jozsa</a></li>
<li class="toctree-l2"><a class="reference internal" href="algoritmos/09_3-simon.html">Problema de Simon</a></li>
</ul>
</details></li>
<li class="toctree-l1"><a class="reference external" href="https://qubox.ufsc.br/index.html">Qubox UFSC</a></li>
<li class="toctree-l1"><a class="reference internal" href="10-referencias.html">Referências</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-launch-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Launch interactive content">
    <i class="fas fa-rocket"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://mybinder.org/v2/gh/evandro-crr/ket-book/main?urlpath=lab/tree/book/08-kettutorial.ipynb" target="_blank"
   class="btn btn-sm dropdown-item"
   title="Launch on Binder"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  
    <img alt="Binder logo" src="_static/images/logo_binder.svg">
  </span>
<span class="btn__text-container">Binder</span>
</a>
</li>
      
      
      
      
      <li><a href="https://colab.research.google.com/github/evandro-crr/ket-book/blob/main/book/08-kettutorial.ipynb" target="_blank"
   class="btn btn-sm dropdown-item"
   title="Launch on Colab"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  
    <img alt="Colab logo" src="_static/images/logo_colab.png">
  </span>
<span class="btn__text-container">Colab</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="initThebeSBT()"
  class="btn btn-sm btn-launch-thebe dropdown-item"
  title="Launch Thebe"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-play"></i>
  </span>
<span class="btn__text-container">Live Code</span>
</button>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Baixe esta página">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="_sources/08-kettutorial.ipynb" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Baixar arquivo fonte"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.ipynb</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Imprimir em PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Modo tela cheia"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="Buscar" aria-label="Buscar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<button class="sidebar-toggle secondary-toggle btn btn-sm" title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</button>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Programacão Quântica com Ket</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Conteúdo </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#introducao">Introdução</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#instalacao">Instalação</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#documentacao">Documentação</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#importando-o-ket">Importando o Ket</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#processo-quantico">Processo Quântico</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#alocacao-de-qubits">Alocação de Qubits</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#portas-logicas-quanticas">Portas Lógicas Quânticas</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#portas-de-1-qubit">Portas de 1 Qubit</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#portas-de-pauli-e-de-hadamard">Portas de Pauli e de Hadamard</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#portas-parametrizadas">Portas Parametrizadas</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#concatenando-portas-quanticas">Concatenando Portas Quânticas</a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#encadeamento-de-chamadas-de-funcao">Encadeamento de chamadas de função</a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#concatenacao-de-portas">Concatenação de portas</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#portas-de-2-qubits">Portas de 2 Qubits</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#produto-tensorial-de-portas">Produto Tensorial de Portas</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#instrucoes-quanticas">Instruções Quânticas</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#operacoes-controladas">Operações Controladas</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#exercicio-implementando-o-estado-ghz">Exercício: Implementando o Estado GHZ</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#operacoes-inversas">Operações Inversas</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#operacoes-uvu-dagger">Operações <span class="math notranslate nohighlight">\(UVU^\dagger\)</span></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#alterando-o-estado-de-controle">Alterando o Estado de Controle</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#exercicio-implementando-portas-quanticas-com-with-around">Exercício: Implementando Portas Quânticas com <code class="docutils literal notranslate"><span class="pre">with</span> <span class="pre">around</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#medidas">Medidas</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#extrair-o-estado-quantico">Extrair o Estado Quântico</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#medicao-de-qubits">Medição de Qubits</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#exercicio-medidas-em-outras-bases">Exercício: Medidas em Outras Bases</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#amostragem-de-qubits">Amostragem de Qubits</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#calcular-valor-esperado">Calcular Valor Esperado</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#execucao-quantica-e-simulacao">Execução Quântica e Simulação</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#modos-de-execucao-quantica">Modos de Execução Quântica</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#configuracao-do-processo-e-dos-simuladores">Configuração do Processo e dos Simuladores</a></li>
</ul>
</li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <div class="cell tag_hide-input tag_thebe-init tag_remove-output docutils container">
<details class="admonition hide above-input">
<summary aria-label="Toggle hidden content">
<p class="collapsed admonition-title">Show code cell source</p>
<p class="expanded admonition-title">Hide code cell source</p>
</summary>
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">!</span>pip<span class="w"> </span>install<span class="w"> </span>-U<span class="w"> </span>-q<span class="w"> </span>pip
<span class="o">!</span>pip<span class="w"> </span>install<span class="w"> </span>-U<span class="w"> </span>-q<span class="w"> </span><span class="s1">&#39;ket-lang[full]&gt;=0.9,&lt;0.10&#39;</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">IPython.display</span><span class="w"> </span><span class="kn">import</span> <span class="n">display</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">plotly.io</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pio</span>

<span class="n">pio</span><span class="o">.</span><span class="n">renderers</span><span class="o">.</span><span class="n">default</span> <span class="o">=</span> <span class="s2">&quot;iframe&quot;</span>
</pre></div>
</div>
</div>
</details>
</div>
<section class="tex2jax_ignore mathjax_ignore" id="programacao-quantica-com-ket">
<h1>Programacão Quântica com Ket<a class="headerlink" href="#programacao-quantica-com-ket" title="Link para este cabeçalho">#</a></h1>
<p>Neste capítulo, exploraremos a plataforma de programação quântica Ket, um projeto de código aberto que permite desenvolver e testar aplicações quânticas.</p>
<section id="introducao">
<h2>Introdução<a class="headerlink" href="#introducao" title="Link para este cabeçalho">#</a></h2>
<section id="instalacao">
<h3>Instalação<a class="headerlink" href="#instalacao" title="Link para este cabeçalho">#</a></h3>
<p>Se você estiver executando esta página com <i class="fas fa-rocket"></i> <strong>Live Code</strong>, o Ket será instalado automaticamente quando o ambiente de execução for carregado. Caso esteja utilizando um Notebook <i class="fas fa-download"></i> baixado desta página ou acessando via <i class="fas fa-rocket"></i> <strong>Binder/Colab</strong>, os comandos de instalação estarão na primeira célula do notebook.</p>
<p>Para integrar o Ket em um projeto externo, instale-o via PyPI utilizando o seguinte comando:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>pip<span class="w"> </span>install<span class="w"> </span>-U<span class="w"> </span>pip
pip<span class="w"> </span>install<span class="w"> </span>ket-lang
</pre></div>
</div>
</section>
<section id="documentacao">
<h3>Documentação<a class="headerlink" href="#documentacao" title="Link para este cabeçalho">#</a></h3>
<p>A documentação completa da API do Ket está disponível em <a class="reference external" href="https://quantumket.org">quantumket.org</a>. Caso tenha dúvidas sobre alguma função ou queira conhecer as funcionalidades disponíveis, recomendamos a consulta à documentação. Além disso, todas as classes, métodos e funções referenciados nesta página possuem links diretos para suas respectivas documentações. Sempre que encontrar um novo elemento, sugerimos a leitura do material correspondente para uma compreensão mais detalhada.</p>
</section>
<section id="importando-o-ket">
<h3>Importando o Ket<a class="headerlink" href="#importando-o-ket" title="Link para este cabeçalho">#</a></h3>
<p>A célula abaixo importa todas as funcionalidades do Ket, permitindo o acesso direto a todas as suas classes e funções:</p>
<div class="cell tag_thebe-init docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">ket</span><span class="w"> </span><span class="kn">import</span> <span class="o">*</span>
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="processo-quantico">
<h2>Processo Quântico<a class="headerlink" href="#processo-quantico" title="Link para este cabeçalho">#</a></h2>
<p>Por trás de toda execução quântica no Ket, há um processo quântico, uma instância da classe <a class="reference external" href="https://quantumket.org/ket/api/ket.base.html#ket.base.Process" title="(em Ket Quantum Programming)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Process</span></code></a>. Ele é responsável por gerenciar desde a alocação dos qubits até a compilação do código quântico.</p>
<p>Para iniciar uma execução quântica, é necessário instanciar um <a class="reference external" href="https://quantumket.org/ket/api/ket.base.html#ket.base.Process" title="(em Ket Quantum Programming)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Process</span></code></a>. Existem diversas configurações que podem ser ajustadas, mas um bom ponto de partida é utilizar o construtor padrão. Se nenhum argumento for passado, o simulador <strong>KBW Sparse</strong> será utilizado com <strong>32 qubits</strong>, e a <strong>execução dinâmica</strong> (<em>live execution</em>) será ativada por padrão.</p>
<p>Exploraremos o significado de cada parâmetro mais adiante neste capítulo.</p>
<p>Abaixo, temos a criação de um processo:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">processo</span> <span class="o">=</span> <span class="n">Process</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<section id="alocacao-de-qubits">
<h3>Alocação de Qubits<a class="headerlink" href="#alocacao-de-qubits" title="Link para este cabeçalho">#</a></h3>
<p>Na computação quântica, a unidade básica de computação é o <strong>qubit</strong>. No Ket, o elemento fundamental da programação é a classe <a class="reference external" href="https://quantumket.org/ket/api/ket.base.html#ket.base.Quant" title="(em Ket Quantum Programming)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Quant</span></code></a>, que nada mais é do que uma lista de qubits. Toda operação quântica, seja a aplicação de portas lógicas ou medições, é realizada sobre um objeto do tipo <a class="reference external" href="https://quantumket.org/ket/api/ket.base.html#ket.base.Quant" title="(em Ket Quantum Programming)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Quant</span></code></a>.</p>
<p>Em breve, veremos como aplicar essas operações nos qubits, mas primeiro, vamos entender como instanciá-los.</p>
<p>No Ket, um qubit está sempre associado a um <a class="reference external" href="https://quantumket.org/ket/api/ket.base.html#ket.base.Process" title="(em Ket Quantum Programming)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Process</span></code></a>. Para acessar qubits, é necessário fazer uma chamada de alocação para o processo quântico, utilizando o método <a class="reference external" href="https://quantumket.org/ket/api/ket.base.html#ket.base.Process.alloc" title="(em Ket Quantum Programming)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">alloc()</span></code></a>. O resultado dessa alocação é uma lista de qubits encapsulada em um objeto <a class="reference external" href="https://quantumket.org/ket/api/ket.base.html#ket.base.Quant" title="(em Ket Quantum Programming)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Quant</span></code></a>. Mesmo que apenas um qubit seja alocado, ele ainda estará dentro de um <a class="reference external" href="https://quantumket.org/ket/api/ket.base.html#ket.base.Quant" title="(em Ket Quantum Programming)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Quant</span></code></a>.</p>
<p>Em muitos casos, um processo quântico é criado apenas para alocar qubits. No entanto, ele também armazena <strong>metadados</strong> (<a class="reference external" href="https://quantumket.org/ket/api/ket.base.html#ket.base.Process.get_metadata" title="(em Ket Quantum Programming)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_metadata()</span></code></a>), que podem ser úteis para experimentos e análises.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Dentro de um <a class="reference external" href="https://quantumket.org/ket/api/ket.base.html#ket.base.Quant" title="(em Ket Quantum Programming)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Quant</span></code></a>, os qubits são referências opacas. Isso significa que eles não armazenam diretamente a informação quântica, mas sim uma referência a essa informação dentro do computador quântico. Além disso, os qubits expostos ao programador são <strong>qubits lógicos</strong>, que, após o processo de compilação, serão mapeados para <strong>qubits físicos</strong> no hardware quântico.</p>
</div>
<p>A classe <a class="reference external" href="https://quantumket.org/ket/api/ket.base.html#ket.base.Quant" title="(em Ket Quantum Programming)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Quant</span></code></a> funciona como uma lista de qubits, e suas instâncias suportam as operações padrão do Python para listas. Por exemplo, é possível:</p>
<ul class="simple">
<li><p><strong>Indexar</strong> qubits usando colchetes <code class="docutils literal notranslate"><span class="pre">[]</span></code>.</p></li>
<li><p><strong>Concatenar</strong> dois objetos <a class="reference external" href="https://quantumket.org/ket/api/ket.base.html#ket.base.Quant" title="(em Ket Quantum Programming)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Quant</span></code></a> utilizando o operador de adição <code class="docutils literal notranslate"><span class="pre">+</span></code>.</p></li>
</ul>
<p>Abaixo, temos exemplos de alocação de qubits:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Instanciando um novo processo quântico</span>
<span class="n">processo</span> <span class="o">=</span> <span class="n">Process</span><span class="p">()</span>

<span class="c1"># Alocação de um único qubit</span>
<span class="n">qubits</span> <span class="o">=</span> <span class="n">processo</span><span class="o">.</span><span class="n">alloc</span><span class="p">()</span>

<span class="c1"># Alocação de dois qubits</span>
<span class="n">par_qubit</span> <span class="o">=</span> <span class="n">processo</span><span class="o">.</span><span class="n">alloc</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

<span class="c1"># Acessando os qubits individualmente</span>
<span class="n">primeiro_qubit</span> <span class="o">=</span> <span class="n">par_qubit</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">segundo_qubit</span> <span class="o">=</span> <span class="n">par_qubit</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

<span class="c1"># Concatenando os qubits</span>
<span class="n">qubits_concatenados</span> <span class="o">=</span> <span class="n">qubits</span> <span class="o">+</span> <span class="n">primeiro_qubit</span> <span class="o">+</span> <span class="n">segundo_qubit</span>

<span class="c1"># Mostrando os qubits alocados e concatenados</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Qubit alocado:&quot;</span><span class="p">,</span> <span class="n">qubits</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Par de qubits alocados:&quot;</span><span class="p">,</span> <span class="n">par_qubit</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Qubits concatenados:&quot;</span><span class="p">,</span> <span class="n">qubits_concatenados</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Qubit alocado: &lt;Ket &#39;Quant&#39; [0] pid=0x7fbd8408f820&gt;
Par de qubits alocados: &lt;Ket &#39;Quant&#39; [1, 2] pid=0x7fbd8408f820&gt;
Qubits concatenados: &lt;Ket &#39;Quant&#39; [0, 1, 2] pid=0x7fbd8408f820&gt;
</pre></div>
</div>
</div>
</div>
<p>Ao imprimir na tela uma variável do tipo <a class="reference external" href="https://quantumket.org/ket/api/ket.base.html#ket.base.Quant" title="(em Ket Quantum Programming)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Quant</span></code></a>, podemos observar uma lista com os índices dos qubits que esse objeto referencia.</p>
<p>É importante notar que, ao indexarmos elementos em um <a class="reference external" href="https://quantumket.org/ket/api/ket.base.html#ket.base.Quant" title="(em Ket Quantum Programming)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Quant</span></code></a>, mesmo que estejamos acessando apenas um qubit, o retorno sempre será outro objeto do tipo <a class="reference external" href="https://quantumket.org/ket/api/ket.base.html#ket.base.Quant" title="(em Ket Quantum Programming)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Quant</span></code></a>. No Ket, os qubits estão sempre encapsulados em instâncias dessa classe.</p>
</section>
</section>
<section id="portas-logicas-quanticas">
<h2>Portas Lógicas Quânticas<a class="headerlink" href="#portas-logicas-quanticas" title="Link para este cabeçalho">#</a></h2>
<p>O Ket oferece um conjunto universal de portas lógicas quânticas, permitindo a descrição de qualquer computação quântica. Todas as portas implementadas no Ket estão disponíveis no módulo <a class="reference external" href="https://quantumket.org/ket/api/ket.gates.html#module-ket.gates" title="(em Ket Quantum Programming)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">gates</span></code></a>. Na documentação, é possível visualizar tanto a representação matricial das portas quanto seus efeitos.</p>
<section id="portas-de-1-qubit">
<h3>Portas de 1 Qubit<a class="headerlink" href="#portas-de-1-qubit" title="Link para este cabeçalho">#</a></h3>
<p>As portas quânticas são aplicadas diretamente a qubits encapsulados em objetos <a class="reference external" href="https://quantumket.org/ket/api/ket.base.html#ket.base.Quant" title="(em Ket Quantum Programming)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Quant</span></code></a>. No Ket, os qubits são implementados como referências opacas, garantindo que a aplicação de portas quânticas não tenha efeitos colaterais no estado clássico do sistema, afetando apenas o estado quântico.</p>
<p>As portas implementadas no Ket seguem a convenção de nomes em letras maiúsculas. Por exemplo, as <strong>portas de Pauli</strong> incluem <a class="reference external" href="https://quantumket.org/ket/api/ket.gates.html#ket.gates.X" title="(em Ket Quantum Programming)"><code class="xref py py-func docutils literal notranslate"><span class="pre">X()</span></code></a>, <a class="reference external" href="https://quantumket.org/ket/api/ket.gates.html#ket.gates.Y" title="(em Ket Quantum Programming)"><code class="xref py py-func docutils literal notranslate"><span class="pre">Y()</span></code></a> e <a class="reference external" href="https://quantumket.org/ket/api/ket.gates.html#ket.gates.Z" title="(em Ket Quantum Programming)"><code class="xref py py-func docutils literal notranslate"><span class="pre">Z()</span></code></a>, enquanto a <strong>porta de Hadamard</strong> é representada por <a class="reference external" href="https://quantumket.org/ket/api/ket.gates.html#ket.gates.H" title="(em Ket Quantum Programming)"><code class="xref py py-func docutils literal notranslate"><span class="pre">H()</span></code></a>.</p>
<section id="portas-de-pauli-e-de-hadamard">
<h4>Portas de Pauli e de Hadamard<a class="headerlink" href="#portas-de-pauli-e-de-hadamard" title="Link para este cabeçalho">#</a></h4>
<p>As portas de Pauli e a porta de Hadamard são fundamentais para muitos algoritmos quânticos. As portas de Pauli realizam rotações de 180º nos eixos X, Y e Z da <a class="reference internal" href="05-postulados.html#esfera-de-bloch"><span class="std std-ref">esfera de Bloch</span></a>. No entanto, essas portas, por si só, não são suficientes para gerar <strong>superposição</strong>. Para isso, utilizamos a porta de Hadamard, que transforma um qubit do estado <span class="math notranslate nohighlight">\(\ket{0}\)</span> ou <span class="math notranslate nohighlight">\(\ket{1}\)</span> para o estado de superposição:</p>
<div class="math notranslate nohighlight">
\[
\frac{1}{\sqrt{2}}(\ket{0} \pm \ket{1})
\]</div>
<div class="admonition tip">
<p class="admonition-title">Dica</p>
<p>Para visualizar o efeito das portas, podemos utilizar o comando:<br />
<code class="docutils literal notranslate"><span class="pre">dump(&lt;qubits&gt;).sphere()</span></code></p>
</div>
<p>A seguir, apresentamos um exemplo que demonstra a aplicação das <strong>portas de Pauli</strong> e da <strong>porta de Hadamard</strong>. Recomendamos que você execute este código e experimente modificar a aplicação das portas para entender melhor seus efeitos:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Instanciando um novo do processo quântico</span>
<span class="n">processo</span> <span class="o">=</span> <span class="n">Process</span><span class="p">()</span>

<span class="c1"># Alocação de um qubit</span>
<span class="n">qubits</span> <span class="o">=</span> <span class="n">processo</span><span class="o">.</span><span class="n">alloc</span><span class="p">()</span>

<span class="n">X</span><span class="p">(</span><span class="n">qubits</span><span class="p">)</span>  <span class="c1"># Porta de Pauli X</span>
<span class="n">Y</span><span class="p">(</span><span class="n">qubits</span><span class="p">)</span>  <span class="c1"># Porta de Pauli Y</span>
<span class="n">Z</span><span class="p">(</span><span class="n">qubits</span><span class="p">)</span>  <span class="c1"># Porta de Pauli Z</span>
<span class="n">H</span><span class="p">(</span><span class="n">qubits</span><span class="p">)</span>  <span class="c1"># Porta de Hadamard</span>

<span class="n">dump</span><span class="p">(</span><span class="n">qubits</span><span class="p">)</span><span class="o">.</span><span class="n">sphere</span><span class="p">()</span>  <span class="c1"># Mostra o Bloch Sphere</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><iframe
    scrolling="no"
    width="100%"
    height="545px"
    src="iframe_figures/figure_5.html"
    frameborder="0"
    allowfullscreen
></iframe>
</div></div>
</div>
</section>
<section id="portas-parametrizadas">
<h4>Portas Parametrizadas<a class="headerlink" href="#portas-parametrizadas" title="Link para este cabeçalho">#</a></h4>
<p>Além das portas de Pauli e da porta de Hadamard, o Ket também oferece <strong>portas de rotação</strong> e a <strong>porta de fase</strong>, que desempenham um papel essencial na construção de algoritmos quânticos.</p>
<p>As portas de rotação, como <a class="reference external" href="https://quantumket.org/ket/api/ket.gates.html#ket.gates.RX" title="(em Ket Quantum Programming)"><code class="xref py py-func docutils literal notranslate"><span class="pre">RX()</span></code></a>, <a class="reference external" href="https://quantumket.org/ket/api/ket.gates.html#ket.gates.RY" title="(em Ket Quantum Programming)"><code class="xref py py-func docutils literal notranslate"><span class="pre">RY()</span></code></a> e <a class="reference external" href="https://quantumket.org/ket/api/ket.gates.html#ket.gates.RZ" title="(em Ket Quantum Programming)"><code class="xref py py-func docutils literal notranslate"><span class="pre">RZ()</span></code></a>, realizam rotações controladas em torno dos eixos X, Y e Z, respectivamente. Essas portas permitem manipular o estado de um qubit de forma precisa e controlada.</p>
<p>Já a porta de fase, representada por <a class="reference external" href="https://quantumket.org/ket/api/ket.gates.html#ket.gates.PHASE" title="(em Ket Quantum Programming)"><code class="xref py py-func docutils literal notranslate"><span class="pre">PHASE()</span></code></a>, aplica uma fase ao estado do qubit. Essas portas são chamadas de portas parametrizadas, pois recebem um parâmetro clássico (um número real, <code class="docutils literal notranslate"><span class="pre">float</span></code>), que controla a operação aplicada.</p>
<p>A porta <a class="reference external" href="https://quantumket.org/ket/api/ket.gates.html#ket.gates.RZ" title="(em Ket Quantum Programming)"><code class="xref py py-func docutils literal notranslate"><span class="pre">RZ()</span></code></a> e a <a class="reference external" href="https://quantumket.org/ket/api/ket.gates.html#ket.gates.PHASE" title="(em Ket Quantum Programming)"><code class="xref py py-func docutils literal notranslate"><span class="pre">PHASE()</span></code></a> são equivalentes em termos de fase global, ou seja, ao analisarmos seu efeito na esfera de Bloch, não conseguimos distingui-las. No entanto, quando usadas em operações controladas, a fase global pode gerar diferenças no estado quântico.</p>
<p>A seguir, apresentamos um exemplo que demonstra a aplicação das portas parametrizadas. Recomendamos que você execute este código e experimente modificar os parâmetros das portas para compreender melhor seus efeitos:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Instanciando um novo do processo quântico</span>
<span class="n">processo</span> <span class="o">=</span> <span class="n">Process</span><span class="p">()</span>

<span class="c1"># Alocação de um qubit</span>
<span class="n">qubits</span> <span class="o">=</span> <span class="n">processo</span><span class="o">.</span><span class="n">alloc</span><span class="p">()</span>

<span class="c1"># Aplicação das portas parametrizadas</span>
<span class="n">RX</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">qubits</span><span class="p">)</span>  <span class="c1"># Porta de rotação Rx com ângulo de 0.5 radianos</span>
<span class="n">RY</span><span class="p">(</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">qubits</span><span class="p">)</span>  <span class="c1"># Porta de rotação Ry com ângulo de 0.2 radianos</span>
<span class="n">RZ</span><span class="p">(</span><span class="mf">2.3</span><span class="p">,</span> <span class="n">qubits</span><span class="p">)</span>  <span class="c1"># Porta de rotação Rz com ângulo de 2.3 radianos</span>
<span class="n">PHASE</span><span class="p">(</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">qubits</span><span class="p">)</span>  <span class="c1"># Porta de fase com ângulo de 0.2 radianos</span>

<span class="n">dump</span><span class="p">(</span><span class="n">qubits</span><span class="p">)</span><span class="o">.</span><span class="n">sphere</span><span class="p">()</span>  <span class="c1"># Mostra o Bloch Sphere</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>/tmp/ipykernel_2263/220369460.py:11: DeprecationWarning:

PHASE is deprecated and will be removed in future versions. Use P(theta, qubits) instead.
</pre></div>
</div>
<div class="output text_html"><iframe
    scrolling="no"
    width="100%"
    height="545px"
    src="iframe_figures/figure_6.html"
    frameborder="0"
    allowfullscreen
></iframe>
</div></div>
</div>
</section>
<section id="concatenando-portas-quanticas">
<h4>Concatenando Portas Quânticas<a class="headerlink" href="#concatenando-portas-quanticas" title="Link para este cabeçalho">#</a></h4>
<p>Ao listar a aplicação de portas lógicas quânticas linha por linha, podemos inflar desnecessariamente o número de linhas de código, tornando o programa menos legível e mais difícil de entender. Para evitar esse problema, uma prática útil na implementação de algoritmos quânticos é a concatenação de portas lógicas, que permite expressar operações de forma mais concisa.</p>
<p>No Ket, existem duas maneiras de concatenar portas lógicas.</p>
<section id="encadeamento-de-chamadas-de-funcao">
<h5>Encadeamento de chamadas de função<a class="headerlink" href="#encadeamento-de-chamadas-de-funcao" title="Link para este cabeçalho">#</a></h5>
<p>Essa abordagem é recomendada quando o número de portas encadeadas não é muito grande. No entanto, o uso excessivo de parênteses pode comprometer a legibilidade do código. Como cada porta implementada no Ket retorna o próprio objeto <a class="reference external" href="https://quantumket.org/ket/api/ket.base.html#ket.base.Quant" title="(em Ket Quantum Programming)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Quant</span></code></a> passado como parâmetro, podemos encadear as operações conforme mostrado no exemplo abaixo:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Instanciando um novo do processo quântico</span>
<span class="n">processo</span> <span class="o">=</span> <span class="n">Process</span><span class="p">()</span>

<span class="c1"># Alocação de um qubit</span>
<span class="n">qubits</span> <span class="o">=</span> <span class="n">processo</span><span class="o">.</span><span class="n">alloc</span><span class="p">()</span>

<span class="n">H</span><span class="p">(</span><span class="n">Z</span><span class="p">(</span><span class="n">H</span><span class="p">(</span><span class="n">qubits</span><span class="p">)))</span>  <span class="c1"># Equivalente a:</span>
<span class="c1"># H(qubit)</span>
<span class="c1"># Z(qubit)</span>
<span class="c1"># H(qubit)</span>

<span class="n">dump</span><span class="p">(</span><span class="n">qubits</span><span class="p">)</span><span class="o">.</span><span class="n">sphere</span><span class="p">()</span>  <span class="c1"># Mostra o Bloch Sphere</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><iframe
    scrolling="no"
    width="100%"
    height="545px"
    src="iframe_figures/figure_7.html"
    frameborder="0"
    allowfullscreen
></iframe>
</div></div>
</div>
</section>
<section id="concatenacao-de-portas">
<h5>Concatenação de portas<a class="headerlink" href="#concatenacao-de-portas" title="Link para este cabeçalho">#</a></h5>
<p>A segunda opção é utilizar a função <a class="reference external" href="https://quantumket.org/ket/api/ket.operations.html#ket.operations.cat" title="(em Ket Quantum Programming)"><code class="xref py py-func docutils literal notranslate"><span class="pre">cat()</span></code></a>, que permite criar uma nova porta representando a concatenação das portas passadas como argumento.</p>
<p>Essa abordagem é especialmente útil em situações onde precisamos armazenar ou reutilizar uma sequência específica de operações quânticas. Ao criar uma nova porta quântica com <a class="reference external" href="https://quantumket.org/ket/api/ket.operations.html#ket.operations.cat" title="(em Ket Quantum Programming)"><code class="xref py py-func docutils literal notranslate"><span class="pre">cat()</span></code></a>, podemos encapsular essa sequência de operações em uma única entidade. Isso torna o código mais modular, facilita a reutilização de blocos de operações e melhora a organização do programa.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Instanciando um novo do processo quântico</span>
<span class="n">processo</span> <span class="o">=</span> <span class="n">Process</span><span class="p">()</span>

<span class="c1"># Alocação de um qubit</span>
<span class="n">qubits</span> <span class="o">=</span> <span class="n">processo</span><span class="o">.</span><span class="n">alloc</span><span class="p">()</span>

<span class="n">porta_X</span> <span class="o">=</span> <span class="n">cat</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">H</span><span class="p">)</span>  <span class="c1"># Concatena portas</span>

<span class="n">porta_X</span><span class="p">(</span><span class="n">qubits</span><span class="p">)</span>

<span class="n">dump</span><span class="p">(</span><span class="n">qubits</span><span class="p">)</span><span class="o">.</span><span class="n">sphere</span><span class="p">()</span>  <span class="c1"># Mostra o Bloch Sphere</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><iframe
    scrolling="no"
    width="100%"
    height="545px"
    src="iframe_figures/figure_8.html"
    frameborder="0"
    allowfullscreen
></iframe>
</div></div>
</div>
<p>Para concatenar portas parametrizadas usando a função <a class="reference external" href="https://quantumket.org/ket/api/ket.operations.html#ket.operations.cat" title="(em Ket Quantum Programming)"><code class="xref py py-func docutils literal notranslate"><span class="pre">cat()</span></code></a>, basta fornecer o argumento clássico correspondente. Quando apenas esse argumento é passado, a função cria uma nova porta com o parâmetro já aplicado.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">math</span><span class="w"> </span><span class="kn">import</span> <span class="n">pi</span>

<span class="c1"># Instanciando um novo do processo quântico</span>
<span class="n">processo</span> <span class="o">=</span> <span class="n">Process</span><span class="p">()</span>

<span class="c1"># Alocação de um qubit</span>
<span class="n">qubits</span> <span class="o">=</span> <span class="n">processo</span><span class="o">.</span><span class="n">alloc</span><span class="p">()</span>

<span class="n">porta_H</span> <span class="o">=</span> <span class="n">cat</span><span class="p">(</span><span class="n">RY</span><span class="p">(</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="n">RX</span><span class="p">(</span><span class="n">pi</span><span class="p">))</span>
<span class="n">porta_X</span> <span class="o">=</span> <span class="n">cat</span><span class="p">(</span><span class="n">porta_H</span><span class="p">,</span> <span class="n">RZ</span><span class="p">(</span><span class="n">pi</span><span class="p">),</span> <span class="n">porta_H</span><span class="p">)</span>

<span class="n">porta_X</span><span class="p">(</span><span class="n">qubits</span><span class="p">)</span>

<span class="n">dump</span><span class="p">(</span><span class="n">qubits</span><span class="p">)</span><span class="o">.</span><span class="n">sphere</span><span class="p">()</span>  <span class="c1"># Mostra o Bloch Sphere</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><iframe
    scrolling="no"
    width="100%"
    height="545px"
    src="iframe_figures/figure_9.html"
    frameborder="0"
    allowfullscreen
></iframe>
</div></div>
</div>
</section>
</section>
</section>
<section id="portas-de-2-qubits">
<h3>Portas de 2 Qubits<a class="headerlink" href="#portas-de-2-qubits" title="Link para este cabeçalho">#</a></h3>
<p>Para explorar todo o potencial da computação quântica, é necessário utilizar o <strong>entrelaçamento</strong> quântico, que requer o uso de portas que operam em dois qubits, como a <a class="reference external" href="https://quantumket.org/ket/api/ket.gates.html#ket.gates.CNOT" title="(em Ket Quantum Programming)"><code class="xref py py-func docutils literal notranslate"><span class="pre">CNOT()</span></code></a>. Juntas com as portas de 1 qubit apresentadas anteriormente, a porta <a class="reference external" href="https://quantumket.org/ket/api/ket.gates.html#ket.gates.CNOT" title="(em Ket Quantum Programming)"><code class="xref py py-func docutils literal notranslate"><span class="pre">CNOT()</span></code></a> forma um conjunto universal de portas lógicas quânticas. Além disso, o Ket oferece outras portas para facilitar a implementação de algoritmos quânticos, como <a class="reference external" href="https://quantumket.org/ket/api/ket.gates.html#ket.gates.SWAP" title="(em Ket Quantum Programming)"><code class="xref py py-func docutils literal notranslate"><span class="pre">SWAP()</span></code></a>, <a class="reference external" href="https://quantumket.org/ket/api/ket.gates.html#ket.gates.RXX" title="(em Ket Quantum Programming)"><code class="xref py py-func docutils literal notranslate"><span class="pre">RXX()</span></code></a>, <a class="reference external" href="https://quantumket.org/ket/api/ket.gates.html#ket.gates.RYY" title="(em Ket Quantum Programming)"><code class="xref py py-func docutils literal notranslate"><span class="pre">RYY()</span></code></a> e <a class="reference external" href="https://quantumket.org/ket/api/ket.gates.html#ket.gates.RZZ" title="(em Ket Quantum Programming)"><code class="xref py py-func docutils literal notranslate"><span class="pre">RZZ()</span></code></a>.</p>
<p>Para exemplificar o uso de portas de 2 qubits, vamos criar um <strong>estado de Bell</strong>:</p>
<div class="math notranslate nohighlight">
\[
\frac{1}{\sqrt{2}}(\ket{00} + \ket{11})
\]</div>
<p>Para isso, podemos utilizar a porta <a class="reference external" href="https://quantumket.org/ket/api/ket.gates.html#ket.gates.CNOT" title="(em Ket Quantum Programming)"><code class="xref py py-func docutils literal notranslate"><span class="pre">CNOT()</span></code></a>.</p>
<div class="admonition tip">
<p class="admonition-title">Dica</p>
<p>Como a geração de entrelaçamento requer dois ou mais qubits, não podemos mais usar a <code class="docutils literal notranslate"><span class="pre">dump(&lt;qubits&gt;).sphere()</span></code>. No entanto, podemos utilizar a função <code class="docutils literal notranslate"><span class="pre">dump(qubits).show()</span></code> para imprimir o estado quântico com a combinação linear dos estados da base computacional.</p>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Instanciando um novo  processo quântico</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">Process</span><span class="p">()</span>

<span class="c1"># Alocação de dois qubits</span>
<span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">alloc</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

<span class="c1"># Aplicando a porta Hadamard em &#39;a&#39; para criar superposição</span>
<span class="n">H</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

<span class="c1"># Aplicando a porta CNOT controlada por &#39;a&#39; e alvo &#39;b&#39;</span>
<span class="c1"># para criar o estado de Bell</span>
<span class="n">CNOT</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

<span class="c1"># Imprimindo o estado do sistema</span>
<span class="n">dump</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_latex math notranslate nohighlight">
\[\displaystyle \frac{1}{\sqrt{2}} \left|00\right&gt;+\frac{1}{\sqrt{2}} \left|11\right&gt;\]</div>
</div>
</div>
<p>Assim como ocorre com as portas de 1 qubit, também é possível oncatenar operações com portas de 2 qubits, como exemplificado no código abaixo, que prepara o estado de Bell:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Instanciando um novo processo quântico</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">Process</span><span class="p">()</span>

<span class="c1"># Alocação de dois qubits</span>
<span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">alloc</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

<span class="c1"># Aplicando a porta CNOT controlada por &#39;a&#39; e alvo &#39;b&#39;</span>
<span class="c1"># após a aplicação da porta Hadamard em &#39;a&#39;</span>
<span class="n">CNOT</span><span class="p">(</span><span class="n">H</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">b</span><span class="p">)</span>

<span class="c1"># Imprimindo o estado do sistema</span>
<span class="n">dump</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_latex math notranslate nohighlight">
\[\displaystyle \frac{1}{\sqrt{2}} \left|00\right&gt;+\frac{1}{\sqrt{2}} \left|11\right&gt;\]</div>
</div>
</div>
<section id="produto-tensorial-de-portas">
<h4>Produto Tensorial de Portas<a class="headerlink" href="#produto-tensorial-de-portas" title="Link para este cabeçalho">#</a></h4>
<p>É possível criar portas de múltiplos qubits utilizando o produto tensorial com a função <a class="reference external" href="https://quantumket.org/ket/api/ket.operations.html#ket.operations.kron" title="(em Ket Quantum Programming)"><code class="xref py py-func docutils literal notranslate"><span class="pre">kron()</span></code></a>. Essa função aceita múltiplas portas como argumentos e gera uma nova porta lógica que opera em múltiplos qubits.</p>
<p>Podemos usar a função <a class="reference external" href="https://quantumket.org/ket/api/ket.operations.html#ket.operations.kron" title="(em Ket Quantum Programming)"><code class="xref py py-func docutils literal notranslate"><span class="pre">kron()</span></code></a> em conjunto com a função <a class="reference external" href="https://quantumket.org/ket/api/ket.operations.html#ket.operations.cat" title="(em Ket Quantum Programming)"><code class="xref py py-func docutils literal notranslate"><span class="pre">cat()</span></code></a> para criar uma nova porta de dois qubits que prepara um estado de Bell, como no exemplo abaixo:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Instanciando um novo processo quântico</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">Process</span><span class="p">()</span>

<span class="c1"># Alocação de dois qubits</span>
<span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">alloc</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

<span class="c1"># Concatenando as operações para preparar o estado de Bell</span>
<span class="n">bell</span> <span class="o">=</span> <span class="n">cat</span><span class="p">(</span><span class="n">kron</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">I</span><span class="p">),</span> <span class="n">CNOT</span><span class="p">)</span>
<span class="n">bell</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

<span class="c1"># Imprimindo o estado do sistema</span>
<span class="n">dump</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_latex math notranslate nohighlight">
\[\displaystyle \frac{1}{\sqrt{2}} \left|00\right&gt;+\frac{1}{\sqrt{2}} \left|11\right&gt;\]</div>
</div>
</div>
<p>Neste exemplo, a operação <code class="docutils literal notranslate"><span class="pre">kron(H,</span> <span class="pre">I)</span></code> cria uma porta de dois qubits, aplicando a operação Hadamard em <code class="docutils literal notranslate"><span class="pre">a</span></code> e a operação identidade em <code class="docutils literal notranslate"><span class="pre">b</span></code>. Em seguida, a operação <code class="docutils literal notranslate"><span class="pre">CNOT</span></code> é aplicada como uma operação controlada entre <code class="docutils literal notranslate"><span class="pre">a</span></code> e <code class="docutils literal notranslate"><span class="pre">b</span></code>. Isso resulta na preparação do estado de Bell nos qubits <code class="docutils literal notranslate"><span class="pre">a</span></code> e <code class="docutils literal notranslate"><span class="pre">b</span></code>.</p>
<p>Como <code class="docutils literal notranslate"><span class="pre">bell</span></code> é considerada uma nova porta lógica quântica, podemos usar a função <code class="xref py py-func docutils literal notranslate"><span class="pre">draw()</span></code> para visualizar o circuito quântico que ela representa.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">qulib</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">gate</span><span class="o">=</span><span class="n">bell</span><span class="p">,</span> <span class="n">num_qubits</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output traceback highlight-ipythontb notranslate"><div class="highlight"><pre><span></span><span class="gt">---------------------------------------------------------------------------</span>
<span class="ne">TypeError</span><span class="g g-Whitespace">                                 </span>Traceback (most recent call last)
<span class="n">Cell</span> <span class="n">In</span><span class="p">[</span><span class="mi">13</span><span class="p">],</span> <span class="n">line</span> <span class="mi">1</span>
<span class="ne">----&gt; </span><span class="mi">1</span> <span class="n">qulib</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">gate</span><span class="o">=</span><span class="n">bell</span><span class="p">,</span> <span class="n">num_qubits</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

<span class="ne">TypeError</span>: draw() missing 1 required positional argument: &#39;qubits&#39;
</pre></div>
</div>
</div>
</div>
</section>
</section>
</section>
<section id="instrucoes-quanticas">
<h2>Instruções Quânticas<a class="headerlink" href="#instrucoes-quanticas" title="Link para este cabeçalho">#</a></h2>
<p>Além das portas lógicas quânticas já apresentadas, o Ket oferece instruções que aproveitam a especificidade da computação quântica para facilitar a programação.</p>
<section id="operacoes-controladas">
<h3>Operações Controladas<a class="headerlink" href="#operacoes-controladas" title="Link para este cabeçalho">#</a></h3>
<p>É comum criar portas lógicas quânticas de múltiplos qubits adicionando qubits de controle a portas já existentes. No Libket, a biblioteca de tempo de execução do Ket, apenas portas de 1 qubit são implementadas, mas elas permitem a adição de controles. Por exemplo, podemos gerar a porta <a class="reference external" href="https://quantumket.org/ket/api/ket.gates.html#ket.gates.CNOT" title="(em Ket Quantum Programming)"><code class="xref py py-func docutils literal notranslate"><span class="pre">CNOT()</span></code></a> a partir da porta <a class="reference external" href="https://quantumket.org/ket/api/ket.gates.html#ket.gates.X" title="(em Ket Quantum Programming)"><code class="xref py py-func docutils literal notranslate"><span class="pre">X()</span></code></a>. No Ket, as operações controladas são aplicadas somente se todos os qubits de controle estiverem no estado <span class="math notranslate nohighlight">\(\ket{1}\)</span>.</p>
<p>Existem duas maneiras de realizar operações controladas no Ket:</p>
<ol class="arabic simple">
<li><p>Usando a instrução <code class="docutils literal notranslate"><span class="pre">with</span></code> <a class="reference external" href="https://quantumket.org/ket/api/ket.operations.html#ket.operations.control" title="(em Ket Quantum Programming)"><code class="xref py py-func docutils literal notranslate"><span class="pre">control()</span></code></a> para criar um contexto controlado.</p></li>
<li><p>Utilizando a função <a class="reference external" href="https://quantumket.org/ket/api/ket.operations.html#ket.operations.ctrl" title="(em Ket Quantum Programming)"><code class="xref py py-func docutils literal notranslate"><span class="pre">ctrl()</span></code></a> para criar uma nova porta controlada.</p></li>
</ol>
<p>Abaixo, apresentamos exemplos de como criar as portas CNOT, Toffoli (CCNOT), SWAP e Fredkin (CSWAP) a partir da porta <a class="reference external" href="https://quantumket.org/ket/api/ket.gates.html#ket.gates.X" title="(em Ket Quantum Programming)"><code class="xref py py-func docutils literal notranslate"><span class="pre">X()</span></code></a>.</p>
<p>No Ket, qualquer função Python que aceite qubits como argumento e não realize nenhuma medida ou alocação de qubits pode ser considerada uma porta lógica quântica, o que facilita a criação de novas portas. Além disso, podemos usar a função <code class="xref py py-func docutils literal notranslate"><span class="pre">draw()</span></code> para visualizar a porta gerada.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">meu_cnot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="n">ctrl</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">X</span><span class="p">)(</span><span class="n">b</span><span class="p">)</span>


<span class="n">qulib</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">gate</span><span class="o">=</span><span class="n">meu_cnot</span><span class="p">,</span> <span class="n">num_qubits</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/59e9e4f778d4f607cf18c1978ffbbe5214526c981e0c0e08a19f585b82b48691.png" src="_images/59e9e4f778d4f607cf18c1978ffbbe5214526c981e0c0e08a19f585b82b48691.png" />
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">meu_cnot2</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">with</span> <span class="n">control</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
        <span class="n">X</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>


<span class="n">qulib</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">gate</span><span class="o">=</span><span class="n">meu_cnot2</span><span class="p">,</span> <span class="n">num_qubits</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/59e9e4f778d4f607cf18c1978ffbbe5214526c981e0c0e08a19f585b82b48691.png" src="_images/59e9e4f778d4f607cf18c1978ffbbe5214526c981e0c0e08a19f585b82b48691.png" />
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">toffoli</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
    <span class="n">ctrl</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">,</span> <span class="n">X</span><span class="p">)(</span><span class="n">c</span><span class="p">)</span>


<span class="n">qulib</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">gate</span><span class="o">=</span><span class="n">toffoli</span><span class="p">,</span> <span class="n">num_qubits</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/cdbd4caf0ab69f3061fa5a43b34f957fda28be40bf4f99f4cdb4bdd0e3d229f4.png" src="_images/cdbd4caf0ab69f3061fa5a43b34f957fda28be40bf4f99f4cdb4bdd0e3d229f4.png" />
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">toffoli2</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
    <span class="k">with</span> <span class="n">control</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">):</span>
        <span class="n">X</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>


<span class="n">qulib</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">gate</span><span class="o">=</span><span class="n">toffoli2</span><span class="p">,</span> <span class="n">num_qubits</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/cdbd4caf0ab69f3061fa5a43b34f957fda28be40bf4f99f4cdb4bdd0e3d229f4.png" src="_images/cdbd4caf0ab69f3061fa5a43b34f957fda28be40bf4f99f4cdb4bdd0e3d229f4.png" />
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">meu_swap</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="n">meu_cnot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="n">meu_cnot</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
    <span class="n">meu_cnot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>


<span class="n">qulib</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">gate</span><span class="o">=</span><span class="n">meu_swap</span><span class="p">,</span> <span class="n">num_qubits</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/e6a710b60aca56e55ffabe8e50dbd30fc54ad37d469b8999a336f0f3cd46e392.png" src="_images/e6a710b60aca56e55ffabe8e50dbd30fc54ad37d469b8999a336f0f3cd46e392.png" />
</div>
</div>
<div class="admonition tip">
<p class="admonition-title">Dica</p>
<p>Embora a implementação de <code class="docutils literal notranslate"><span class="pre">meu_swap</span></code> esteja correta, ela não aproveita uma otimização introduzida pelo uso de <code class="docutils literal notranslate"><span class="pre">with</span></code> <a class="reference external" href="https://quantumket.org/ket/api/ket.operations.html#ket.operations.around" title="(em Ket Quantum Programming)"><code class="xref py py-func docutils literal notranslate"><span class="pre">around()</span></code></a>, que será abordada mais adiante neste capítulo.</p>
<p>A ausência dessa otimização pode ser observada no circuito da porta Fredkin abaixo, que não está em sua forma otimizada.</p>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">fredkin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
    <span class="k">with</span> <span class="n">control</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
        <span class="n">meu_swap</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>


<span class="n">qulib</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">gate</span><span class="o">=</span><span class="n">fredkin</span><span class="p">,</span> <span class="n">num_qubits</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/e692205689ec12025c8613339b3df3bf3116bdeb0292656a987ee72efa203a8a.png" src="_images/e692205689ec12025c8613339b3df3bf3116bdeb0292656a987ee72efa203a8a.png" />
</div>
</div>
</section>
<section id="exercicio-implementando-o-estado-ghz">
<h3>Exercício: Implementando o Estado GHZ<a class="headerlink" href="#exercicio-implementando-o-estado-ghz" title="Link para este cabeçalho">#</a></h3>
<p>Neste exercício, o objetivo é usar a função <a class="reference external" href="https://quantumket.org/ket/api/ket.operations.html#ket.operations.ctrl" title="(em Ket Quantum Programming)"><code class="xref py py-func docutils literal notranslate"><span class="pre">ctrl()</span></code></a> para implementar uma porta quântica que prepara o estado GHZ de <span class="math notranslate nohighlight">\(n\)</span> qubits.</p>
<p>O estado GHZ é definido como:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\ket{\text{GHZ}} &amp;= \frac{1}{\sqrt{2}}(\ket{0}^{\otimes n} + \ket{1}^{\otimes n})  \\
&amp;= \frac{1}{\sqrt{2}}(\ket{0} \otimes \ket{0} \otimes \cdots \otimes \ket{0} + \ket{1} \otimes \ket{1} \otimes \cdots \otimes \ket{1})
\end{aligned}
\end{split}\]</div>
<p>Para implementar essa funcionalidade, você precisa completar a função <code class="docutils literal notranslate"><span class="pre">ghz</span></code> que recebe um objeto <a class="reference external" href="https://quantumket.org/ket/api/ket.base.html#ket.base.Quant" title="(em Ket Quantum Programming)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Quant</span></code></a> representando os qubits e realiza as operações necessárias para preparar o estado GHZ.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">ghz</span><span class="p">(</span><span class="n">qubits</span><span class="p">:</span> <span class="n">Quant</span><span class="p">):</span>
    <span class="c1"># Implemente aqui a função ghz usando a função ctrl</span>
    <span class="o">...</span>


<span class="n">n</span> <span class="o">=</span> <span class="mi">10</span>

<span class="n">processo</span> <span class="o">=</span> <span class="n">Process</span><span class="p">()</span>
<span class="n">qubits</span> <span class="o">=</span> <span class="n">processo</span><span class="o">.</span><span class="n">alloc</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

<span class="n">ghz</span><span class="p">(</span><span class="n">qubits</span><span class="p">)</span>

<span class="n">dump</span><span class="p">(</span><span class="n">qubits</span><span class="p">)</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_latex math notranslate nohighlight">
\[\displaystyle  \left|0000000000\right&gt;\]</div>
</div>
</div>
<p>A função <a class="reference external" href="https://quantumket.org/ket/api/ket.operations.html#ket.operations.ctrl" title="(em Ket Quantum Programming)"><code class="xref py py-func docutils literal notranslate"><span class="pre">ctrl()</span></code></a> recebe dois argumentos: um objeto do tipo <a class="reference external" href="https://quantumket.org/ket/api/ket.base.html#ket.base.Quant" title="(em Ket Quantum Programming)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Quant</span></code></a> com os qubits de controle (sendo possível utilizar múltiplos qubits de controle) e uma função que atua como uma porta lógica quântica. É importante ressaltar que a função <a class="reference external" href="https://quantumket.org/ket/api/ket.operations.html#ket.operations.ctrl" title="(em Ket Quantum Programming)"><code class="xref py py-func docutils literal notranslate"><span class="pre">ctrl()</span></code></a> não está limitada a adicionar qubits de controle apenas às portas quânticas disponíveis no módulo <a class="reference external" href="https://quantumket.org/ket/api/ket.gates.html#module-ket.gates" title="(em Ket Quantum Programming)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">gates</span></code></a>, mas pode adicionar qubits de controle a qualquer função. Por exemplo, podemos implementar uma porta de Bell e adicionar qubits de controle a ela como no código abaixo.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">bell</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">Quant</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">Quant</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Quant</span><span class="p">,</span> <span class="n">Quant</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Implementa a preparação do estado de Bell entre dois qubits.</span>

<span class="sd">    Parâmetros:</span>
<span class="sd">        a (Quant): O primeiro qubit.</span>
<span class="sd">        b (Quant): O segundo qubit.</span>

<span class="sd">    Retorna:</span>
<span class="sd">        tuple[Quant, Quant]: Os qubits de entrada a e b.</span>

<span class="sd">    Observação:</span>
<span class="sd">        Por convenção, as portas implementadas no Ket retornam os Quants de</span>
<span class="sd">        entrada para facilitar a concatenação de portas.</span>
<span class="sd">        No entanto, isso não é necessário.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">H</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>  <span class="c1"># Aplica a porta Hadamard ao primeiro qubit</span>
    <span class="n">CNOT</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>  <span class="c1"># Aplica a porta CNOT controlada pelo primeiro qubit &#39;a&#39; e alvo &#39;b&#39;</span>
    <span class="k">return</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span>  <span class="c1"># Retorna os qubits de entrada &#39;a&#39; e &#39;b&#39;</span>


<span class="c1"># Instancia um novo processo quântico</span>
<span class="n">processo</span> <span class="o">=</span> <span class="n">Process</span><span class="p">()</span>

<span class="c1"># Aloca três qubits &#39;a&#39;, &#39;b&#39; e &#39;c&#39;</span>
<span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">processo</span><span class="o">.</span><span class="n">alloc</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

<span class="c1"># Aplica uma operação controlada com o qubit &#39;a&#39; e a função bell aos qubits &#39;b&#39; e &#39;c&#39;</span>
<span class="n">ctrl</span><span class="p">(</span><span class="n">H</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">bell</span><span class="p">)(</span><span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>

<span class="c1"># Imprime o estado do sistema</span>
<span class="n">dump</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_latex math notranslate nohighlight">
\[\displaystyle \frac{1}{\sqrt{2}} \left|000\right&gt;+\frac{1}{\sqrt{4}} \left|100\right&gt;+\frac{1}{\sqrt{4}} \left|111\right&gt;\]</div>
</div>
</div>
</section>
<section id="operacoes-inversas">
<h3>Operações Inversas<a class="headerlink" href="#operacoes-inversas" title="Link para este cabeçalho">#</a></h3>
<p>Com exceção das operações de medida, toda computação quântica é reversível, ou seja, para todas as portas lógicas quânticas existe uma operação inversa correspondente. Isso é explorado em diversos algoritmos quânticos. Por exemplo, o algoritmo de estimação de fase requer uma operação de transformada de Fourier quântica inversa. No entanto, podemos implementar a transformada normalmente no Ket e usar a função <a class="reference external" href="https://quantumket.org/ket/api/ket.operations.html#ket.operations.adj" title="(em Ket Quantum Programming)"><code class="xref py py-func docutils literal notranslate"><span class="pre">adj()</span></code></a> para criar a transformada inversa. Podemos ver isso em ação no código abaixo.</p>
<div class="admonition tip">
<p class="admonition-title">Dica</p>
<p>O código abaixo apresenta algumas operações que ainda não foram vistas neste capítulo. Não se preocupe em entender o código, o objetivo é apenas ilustrar o uso da função <a class="reference external" href="https://quantumket.org/ket/api/ket.operations.html#ket.operations.adj" title="(em Ket Quantum Programming)"><code class="xref py py-func docutils literal notranslate"><span class="pre">adj()</span></code></a>.</p>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">math</span><span class="w"> </span><span class="kn">import</span> <span class="n">pi</span>


<span class="k">def</span><span class="w"> </span><span class="nf">qft</span><span class="p">(</span><span class="n">qubits</span><span class="p">:</span> <span class="n">Quant</span><span class="p">,</span> <span class="n">invert</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">qubits</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">H</span><span class="p">(</span><span class="n">qubits</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="o">*</span><span class="n">init</span><span class="p">,</span> <span class="n">last</span> <span class="o">=</span> <span class="n">qubits</span>
        <span class="n">H</span><span class="p">(</span><span class="n">last</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ctrl_qubit</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">init</span><span class="p">)):</span>
            <span class="n">ctrl</span><span class="p">(</span><span class="n">ctrl_qubit</span><span class="p">,</span> <span class="n">PHASE</span><span class="p">(</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">**</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))(</span><span class="n">last</span><span class="p">)</span>
        <span class="n">qft</span><span class="p">(</span><span class="n">init</span><span class="p">,</span> <span class="n">invert</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">invert</span><span class="p">:</span>
        <span class="n">size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">qubits</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span> <span class="o">//</span> <span class="mi">2</span><span class="p">):</span>
            <span class="n">SWAP</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">qubits</span><span class="p">[</span><span class="n">size</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>


<span class="k">def</span><span class="w"> </span><span class="nf">estimador_de_fase</span><span class="p">(</span><span class="n">oraculo</span><span class="p">,</span> <span class="n">precisão</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="k">assert</span> <span class="n">precisão</span> <span class="o">&lt;=</span> <span class="mi">20</span><span class="p">,</span> <span class="s2">&quot;o tempo de computação pode ser muito grande&quot;</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">Process</span><span class="p">(</span><span class="n">simulator</span><span class="o">=</span><span class="s2">&quot;dense&quot;</span><span class="p">,</span> <span class="n">num_qubits</span><span class="o">=</span><span class="n">precisão</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">ctr</span> <span class="o">=</span> <span class="n">H</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">alloc</span><span class="p">(</span><span class="n">precisão</span><span class="p">))</span>
    <span class="n">tgr</span> <span class="o">=</span> <span class="n">X</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">alloc</span><span class="p">())</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ctr</span><span class="p">):</span>
        <span class="n">ctrl</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">oraculo</span><span class="p">)(</span><span class="n">i</span><span class="p">,</span> <span class="n">tgr</span><span class="p">)</span>

    <span class="n">adj</span><span class="p">(</span><span class="n">qft</span><span class="p">)(</span><span class="n">ctr</span><span class="p">)</span>  <span class="c1"># &lt;- chada da transformada de Fourier quântica inversa</span>

    <span class="k">return</span> <span class="n">measure</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">ctr</span><span class="p">))</span><span class="o">.</span><span class="n">value</span> <span class="o">/</span> <span class="mi">2</span><span class="o">**</span><span class="n">precisão</span>


<span class="n">fase</span> <span class="o">=</span> <span class="n">pi</span>

<span class="n">estimador_de_fase</span><span class="p">(</span>
    <span class="n">oraculo</span><span class="o">=</span><span class="k">lambda</span> <span class="n">i</span><span class="p">,</span> <span class="n">tgr</span><span class="p">:</span> <span class="n">PHASE</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="n">fase</span> <span class="o">/</span> <span class="mi">10</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="o">**</span><span class="n">i</span><span class="p">,</span> <span class="n">tgr</span><span class="p">),</span>
    <span class="n">precisão</span><span class="o">=</span><span class="mi">18</span><span class="p">,</span>
<span class="p">)</span> <span class="o">*</span> <span class="mi">10</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>3.1415939331054688
</pre></div>
</div>
</div>
</div>
<p>Para realizar operações inversas, uma abordagem alternativa é empregar a instrução <code class="docutils literal notranslate"><span class="pre">with</span></code> <a class="reference external" href="https://quantumket.org/ket/api/ket.operations.html#ket.operations.inverse" title="(em Ket Quantum Programming)"><code class="xref py py-func docutils literal notranslate"><span class="pre">inverse()</span></code></a>. Esta instrução cria um contexto onde as operações são executadas na ordem usual do Python, mas as portas lógicas quânticas são aplicadas de maneira inversa no estado quântico. Abaixo está um exemplo que demonstra o uso dessa instrução. Note que é necessário fornecer o <a class="reference external" href="https://quantumket.org/ket/api/ket.base.html#ket.base.Process" title="(em Ket Quantum Programming)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Process</span></code></a> onde as operações inversas serão aplicadas.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">processo</span> <span class="o">=</span> <span class="n">Process</span><span class="p">()</span>

<span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">processo</span><span class="o">.</span><span class="n">alloc</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Estado inicial:&quot;</span><span class="p">)</span>
<span class="n">display</span><span class="p">(</span><span class="n">dump</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">show</span><span class="p">())</span>

<span class="c1"># Prepara o estado de Bell</span>
<span class="n">H</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="n">CNOT</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Estado após a preparação:&quot;</span><span class="p">)</span>
<span class="n">display</span><span class="p">(</span><span class="n">dump</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">show</span><span class="p">())</span>

<span class="c1"># Invertendo a preparação do estado de Bell</span>
<span class="k">with</span> <span class="n">inverse</span><span class="p">(</span><span class="n">processo</span><span class="p">):</span>
    <span class="n">H</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">CNOT</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Estado após a inversão da preparação:&quot;</span><span class="p">)</span>
<span class="n">dump</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Estado inicial:
</pre></div>
</div>
<div class="output text_latex math notranslate nohighlight">
\[\displaystyle  \left|00\right&gt;\]</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Estado após a preparação:
</pre></div>
</div>
<div class="output text_latex math notranslate nohighlight">
\[\displaystyle \frac{1}{\sqrt{2}} \left|00\right&gt;+\frac{1}{\sqrt{2}} \left|11\right&gt;\]</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Estado após a inversão da preparação:
</pre></div>
</div>
<div class="output text_latex math notranslate nohighlight">
\[\displaystyle  \left|00\right&gt;\]</div>
</div>
</div>
</section>
<section id="operacoes-uvu-dagger">
<h3>Operações <span class="math notranslate nohighlight">\(UVU^\dagger\)</span><a class="headerlink" href="#operacoes-uvu-dagger" title="Link para este cabeçalho">#</a></h3>
<p>Uma construção comum em algoritmos quânticos é aplicar uma operação <span class="math notranslate nohighlight">\(U\)</span> em torno de outra operação <span class="math notranslate nohighlight">\(V\)</span>, seguida pela operação inversa <span class="math notranslate nohighlight">\(U^\dagger\)</span>. Essa sequência de operações é representada matematicamente como <span class="math notranslate nohighlight">\(UVU^\dagger\)</span>.</p>
<p>Um exemplo do uso desse tipo de construção está na implementação do difusor do algoritmo de Grover. Nele, uma operação controlada é envolta por portas de Hadamard. Aqui, as portas <span class="math notranslate nohighlight">\(U\)</span> são as portas de Hadamard, e é importante observar que a Hadamard é sua própria inversa. A porta controlada é representada pela porta <span class="math notranslate nohighlight">\(V\)</span>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">difusor</span><span class="p">(</span><span class="n">qubits</span><span class="p">:</span> <span class="n">Quant</span><span class="p">,</span> <span class="n">auxiliar</span><span class="p">:</span> <span class="n">Quant</span><span class="p">):</span>
    <span class="k">with</span> <span class="n">around</span><span class="p">(</span><span class="n">cat</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">X</span><span class="p">),</span> <span class="n">qubits</span><span class="p">):</span>
        <span class="n">ctrl</span><span class="p">(</span><span class="n">qubits</span><span class="p">,</span> <span class="n">X</span><span class="p">)(</span><span class="n">auxiliar</span><span class="p">)</span>


<span class="n">qulib</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">gate</span><span class="o">=</span><span class="n">difusor</span><span class="p">,</span> <span class="n">num_qubits</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">title</span><span class="o">=</span><span class="s2">&quot;Difusor do algoritmo de Grover&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/a78dad22e26d1d3d89a54946fb41a998d6e4228e452848aa9a00faa1d4170689.png" src="_images/a78dad22e26d1d3d89a54946fb41a998d6e4228e452848aa9a00faa1d4170689.png" />
</div>
</div>
<p>Para facilitar essa construção no Ket, a instrução <code class="docutils literal notranslate"><span class="pre">with</span></code> <a class="reference external" href="https://quantumket.org/ket/api/ket.operations.html#ket.operations.around" title="(em Ket Quantum Programming)"><code class="xref py py-func docutils literal notranslate"><span class="pre">around()</span></code></a> é oferecida. No exemplo acima, implementamos o difusor de Grover usando essa instrução.</p>
<p>A título de comparação, a seguir está implementado o difusor de Grover sem usar a instrução <code class="docutils literal notranslate"><span class="pre">with</span></code> <a class="reference external" href="https://quantumket.org/ket/api/ket.operations.html#ket.operations.around" title="(em Ket Quantum Programming)"><code class="xref py py-func docutils literal notranslate"><span class="pre">around()</span></code></a>. Além da redução do número de linhas, o uso de <code class="docutils literal notranslate"><span class="pre">with</span></code> <a class="reference external" href="https://quantumket.org/ket/api/ket.operations.html#ket.operations.around" title="(em Ket Quantum Programming)"><code class="xref py py-func docutils literal notranslate"><span class="pre">around()</span></code></a> torna o código mais legível e menos propenso a erros, proporcionando uma implementação mais eficiente.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">difusor_2</span><span class="p">(</span><span class="n">qubits</span><span class="p">:</span> <span class="n">Quant</span><span class="p">,</span> <span class="n">auxiliar</span><span class="p">:</span> <span class="n">Quant</span><span class="p">):</span>
    <span class="n">H</span><span class="p">(</span><span class="n">qubits</span><span class="p">)</span>
    <span class="n">X</span><span class="p">(</span><span class="n">qubits</span><span class="p">)</span>
    <span class="n">ctrl</span><span class="p">(</span><span class="n">qubits</span><span class="p">,</span> <span class="n">X</span><span class="p">)(</span><span class="n">auxiliar</span><span class="p">)</span>
    <span class="n">X</span><span class="p">(</span><span class="n">qubits</span><span class="p">)</span>
    <span class="n">H</span><span class="p">(</span><span class="n">qubits</span><span class="p">)</span>


<span class="n">qulib</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">gate</span><span class="o">=</span><span class="n">difusor_2</span><span class="p">,</span> <span class="n">num_qubits</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/e1d88607bbd453ecf1fa483588c0959ddbb5a53609f8c71faf24b71f1a1e50de.png" src="_images/e1d88607bbd453ecf1fa483588c0959ddbb5a53609f8c71faf24b71f1a1e50de.png" />
</div>
</div>
<p>Além de facilitar a construção de algumas operações quânticas, a estrutura <code class="docutils literal notranslate"><span class="pre">with</span></code> <a class="reference external" href="https://quantumket.org/ket/api/ket.operations.html#ket.operations.around" title="(em Ket Quantum Programming)"><code class="xref py py-func docutils literal notranslate"><span class="pre">around()</span></code></a> também permite <a class="reference external" href="https://arxiv.org/abs/2406.05581">reduzir o número de qubits de controle em certas operações</a>.</p>
<p>No exemplo abaixo, utilizamos <code class="docutils literal notranslate"><span class="pre">with</span></code> <a class="reference external" href="https://quantumket.org/ket/api/ket.operations.html#ket.operations.around" title="(em Ket Quantum Programming)"><code class="xref py py-func docutils literal notranslate"><span class="pre">around()</span></code></a> para definir uma porta SWAP e, em seguida, empregamos essa mesma porta para implementar uma porta de Fredkin, que é essencialmente uma versão controlada da SWAP.</p>
<p>Note que, no circuito abaixo, há menos qubits de controle em comparação com o exemplo anterior da porta de Fredkin.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">meu_swap_op</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">with</span> <span class="n">around</span><span class="p">(</span><span class="n">CNOT</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="n">CNOT</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">fredkin_op</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
    <span class="n">ctrl</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">meu_swap_op</span><span class="p">)(</span><span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>


<span class="n">qulib</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">gate</span><span class="o">=</span><span class="n">fredkin_op</span><span class="p">,</span> <span class="n">num_qubits</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/d13ce858fd0e492bf6424a9d93a15bdfbc03bc626cb4626c8f7e490b74b8b4b3.png" src="_images/d13ce858fd0e492bf6424a9d93a15bdfbc03bc626cb4626c8f7e490b74b8b4b3.png" />
</div>
</div>
<section id="alterando-o-estado-de-controle">
<h4>Alterando o Estado de Controle<a class="headerlink" href="#alterando-o-estado-de-controle" title="Link para este cabeçalho">#</a></h4>
<p>Por padrão, as operações quânticas são aplicadas apenas quando os qubits de controle estão no estado <span class="math notranslate nohighlight">\(\ket{1}\)</span>. No entanto, em certos casos, precisamos alterar esse comportamento. Para isso, podemos usar a função <code class="xref py py-func docutils literal notranslate"><span class="pre">ket.lib.flip_to_control()</span></code> em conjunto com a instrução <code class="docutils literal notranslate"><span class="pre">with</span></code> <a class="reference external" href="https://quantumket.org/ket/api/ket.operations.html#ket.operations.around" title="(em Ket Quantum Programming)"><code class="xref py py-func docutils literal notranslate"><span class="pre">around()</span></code></a> para mudar o estado de controle de uma operação quântica.</p>
<p>O exemplo abaixo ilustra esse uso, onde queremos aplicar operações condicionais de acordo com os dados carregados. Neste exemplo, as operações condicionais são aplicadas nos qubits <code class="docutils literal notranslate"><span class="pre">qubits</span></code> com base nos dados carregados, e em seguida o emaranhamento é removido condicionalmente de acordo com esses mesmos dados.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">processo</span> <span class="o">=</span> <span class="n">Process</span><span class="p">()</span>

<span class="c1"># Aloca qubits</span>
<span class="n">qubits</span> <span class="o">=</span> <span class="n">processo</span><span class="o">.</span><span class="n">alloc</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
<span class="n">aux</span> <span class="o">=</span> <span class="n">processo</span><span class="o">.</span><span class="n">alloc</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

<span class="c1"># Dados para processamento</span>
<span class="n">dados</span> <span class="o">=</span> <span class="p">[</span><span class="mi">11</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="mi">33</span><span class="p">,</span> <span class="mi">44</span><span class="p">]</span>

<span class="c1"># Aplica a Hadamard no registrador auxiliar</span>
<span class="n">H</span><span class="p">(</span><span class="n">aux</span><span class="p">)</span>

<span class="c1"># Aplica as operações condicionais com base nos dados</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">dado</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dados</span><span class="p">):</span>
    <span class="k">with</span> <span class="n">around</span><span class="p">(</span><span class="n">qulib</span><span class="o">.</span><span class="n">flip_to_control</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">aux</span><span class="p">):</span>
        <span class="k">with</span> <span class="n">control</span><span class="p">(</span><span class="n">aux</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">state</span><span class="p">,</span> <span class="n">qubit</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">dado</span><span class="si">:</span><span class="s2">0</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">qubits</span><span class="p">)</span><span class="si">}</span><span class="s2">b</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">qubits</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">state</span> <span class="o">==</span> <span class="s2">&quot;1&quot;</span><span class="p">:</span>
                    <span class="n">X</span><span class="p">(</span><span class="n">qubit</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Dados carregados:&quot;</span><span class="p">)</span>
<span class="n">display</span><span class="p">(</span><span class="n">dump</span><span class="p">(</span><span class="n">qubits</span> <span class="o">+</span> <span class="n">aux</span><span class="p">)</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;i</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">qubits</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">))</span>

<span class="c1"># Remove o emaranhamento condicionalmente com base nos dados</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">dado</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dados</span><span class="p">):</span>
    <span class="k">with</span> <span class="n">around</span><span class="p">(</span><span class="n">qulib</span><span class="o">.</span><span class="n">flip_to_control</span><span class="p">(</span><span class="n">dado</span><span class="p">),</span> <span class="n">qubits</span><span class="p">):</span>
        <span class="k">with</span> <span class="n">control</span><span class="p">(</span><span class="n">qubits</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">state</span><span class="p">,</span> <span class="n">qubit</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">i</span><span class="si">:</span><span class="s2">0</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">aux</span><span class="p">)</span><span class="si">}</span><span class="s2">b</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">aux</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">state</span> <span class="o">==</span> <span class="s2">&quot;1&quot;</span><span class="p">:</span>
                    <span class="n">X</span><span class="p">(</span><span class="n">qubit</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Emaranhamento removido condicionalmente:&quot;</span><span class="p">)</span>
<span class="n">display</span><span class="p">(</span><span class="n">dump</span><span class="p">(</span><span class="n">qubits</span> <span class="o">+</span> <span class="n">aux</span><span class="p">)</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;i</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">qubits</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Dados carregados:
</pre></div>
</div>
<div class="output text_latex math notranslate nohighlight">
\[\displaystyle \frac{1}{\sqrt{4}} \left|11\right&gt;\left|00\right&gt;+\frac{1}{\sqrt{4}} \left|33\right&gt;\left|10\right&gt;+\frac{1}{\sqrt{4}} \left|22\right&gt;\left|01\right&gt;+\frac{1}{\sqrt{4}} \left|44\right&gt;\left|11\right&gt;\]</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Emaranhamento removido condicionalmente:
</pre></div>
</div>
<div class="output text_latex math notranslate nohighlight">
\[\displaystyle \frac{1}{\sqrt{4}} \left|44\right&gt;\left|00\right&gt;+\frac{1}{\sqrt{4}} \left|22\right&gt;\left|00\right&gt;+\frac{1}{\sqrt{4}} \left|33\right&gt;\left|00\right&gt;+\frac{1}{\sqrt{4}} \left|11\right&gt;\left|00\right&gt;\]</div>
</div>
</div>
</section>
<section id="exercicio-implementando-portas-quanticas-com-with-around">
<h4>Exercício: Implementando Portas Quânticas com <code class="docutils literal notranslate"><span class="pre">with</span> <span class="pre">around</span></code><a class="headerlink" href="#exercicio-implementando-portas-quanticas-com-with-around" title="Link para este cabeçalho">#</a></h4>
<p>Neste exercício, sua tarefa é utilizar a instrução <code class="docutils literal notranslate"><span class="pre">with</span></code> <a class="reference external" href="https://quantumket.org/ket/api/ket.operations.html#ket.operations.around" title="(em Ket Quantum Programming)"><code class="xref py py-func docutils literal notranslate"><span class="pre">around()</span></code></a> para reimplementar as portas lógicas quânticas <a class="reference external" href="https://quantumket.org/ket/api/ket.gates.html#ket.gates.RXX" title="(em Ket Quantum Programming)"><code class="xref py py-func docutils literal notranslate"><span class="pre">RXX()</span></code></a>, <a class="reference external" href="https://quantumket.org/ket/api/ket.gates.html#ket.gates.RYY" title="(em Ket Quantum Programming)"><code class="xref py py-func docutils literal notranslate"><span class="pre">RYY()</span></code></a> e <a class="reference external" href="https://quantumket.org/ket/api/ket.gates.html#ket.gates.RZZ" title="(em Ket Quantum Programming)"><code class="xref py py-func docutils literal notranslate"><span class="pre">RZZ()</span></code></a>. Use como base para a reimplementação o circuito quântico de decomposição de cada porta.</p>
<div class="cell tag_hide-input docutils container">
<details class="admonition hide above-input">
<summary aria-label="Toggle hidden content">
<p class="collapsed admonition-title">Show code cell source</p>
<p class="expanded admonition-title">Hide code cell source</p>
</summary>
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span> <span class="o">=</span> <span class="n">qulib</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">gate</span><span class="o">=</span><span class="n">RXX</span><span class="p">(</span><span class="mf">3.141592654</span><span class="p">),</span> <span class="n">num_qubits</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="n">fig</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s2">&quot;RXX Gate&quot;</span><span class="p">)</span>
<span class="n">fig</span>
</pre></div>
</div>
</div>
</details>
<div class="cell_output docutils container">
<img alt="_images/e69345ddd2c90db39ab575b56c5d7a44d41a570fea2166cb0b2e0050db0c37de.png" src="_images/e69345ddd2c90db39ab575b56c5d7a44d41a570fea2166cb0b2e0050db0c37de.png" />
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">porta_rxx</span><span class="p">(</span><span class="n">theta</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">qubits</span><span class="p">:</span> <span class="n">Quant</span><span class="p">):</span>
    <span class="c1"># Implemente a portas RXX(ϴ)</span>
    <span class="o">...</span>


<span class="n">qulib</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">gate</span><span class="o">=</span><span class="n">porta_rxx</span><span class="p">,</span> <span class="n">num_qubits</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,),</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="mf">3.141592654</span><span class="p">,))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/85d93b13d95c473b274505e919877c6cd016e0c43438070968fe940766633e85.png" src="_images/85d93b13d95c473b274505e919877c6cd016e0c43438070968fe940766633e85.png" />
</div>
</div>
<div class="cell tag_hide-input docutils container">
<details class="admonition hide above-input">
<summary aria-label="Toggle hidden content">
<p class="collapsed admonition-title">Show code cell source</p>
<p class="expanded admonition-title">Hide code cell source</p>
</summary>
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span> <span class="o">=</span> <span class="n">qulib</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">gate</span><span class="o">=</span><span class="n">RYY</span><span class="p">(</span><span class="mf">3.141592654</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="n">num_qubits</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="n">fig</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s2">&quot;RYY Gate&quot;</span><span class="p">)</span>
<span class="n">fig</span>
</pre></div>
</div>
</div>
</details>
<div class="cell_output docutils container">
<img alt="_images/09e514f471f87abde4fbc51e4906aeeef46b80172befac418695d456905e2c31.png" src="_images/09e514f471f87abde4fbc51e4906aeeef46b80172befac418695d456905e2c31.png" />
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">porta_ryy</span><span class="p">(</span><span class="n">theta</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">qubits</span><span class="p">:</span> <span class="n">Quant</span><span class="p">):</span>
    <span class="c1"># Implemente a portas RYY(ϴ)</span>
    <span class="o">...</span>


<span class="n">qulib</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">gate</span><span class="o">=</span><span class="n">porta_ryy</span><span class="p">,</span> <span class="n">num_qubits</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,),</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="mf">3.141592654</span><span class="p">,))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/85d93b13d95c473b274505e919877c6cd016e0c43438070968fe940766633e85.png" src="_images/85d93b13d95c473b274505e919877c6cd016e0c43438070968fe940766633e85.png" />
</div>
</div>
<div class="cell tag_hide-input docutils container">
<details class="admonition hide above-input">
<summary aria-label="Toggle hidden content">
<p class="collapsed admonition-title">Show code cell source</p>
<p class="expanded admonition-title">Hide code cell source</p>
</summary>
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span> <span class="o">=</span> <span class="n">qulib</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">gate</span><span class="o">=</span><span class="n">RZZ</span><span class="p">(</span><span class="mf">3.141592654</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="n">num_qubits</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="n">fig</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s2">&quot;RZZ Gate&quot;</span><span class="p">)</span>
<span class="n">fig</span>
</pre></div>
</div>
</div>
</details>
<div class="cell_output docutils container">
<img alt="_images/91fb12a3d4e5e9100479d08bb8b276aff8f7e9f1b0b29060b46119d794daa63c.png" src="_images/91fb12a3d4e5e9100479d08bb8b276aff8f7e9f1b0b29060b46119d794daa63c.png" />
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">porta_rzz</span><span class="p">(</span><span class="n">theta</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">qubits</span><span class="p">:</span> <span class="n">Quant</span><span class="p">):</span>
    <span class="c1"># Implemente a portas RZZ(ϴ)</span>
    <span class="o">...</span>


<span class="n">qulib</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">gate</span><span class="o">=</span><span class="n">porta_rzz</span><span class="p">,</span> <span class="n">num_qubits</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,),</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="mf">3.141592654</span><span class="p">,))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/85d93b13d95c473b274505e919877c6cd016e0c43438070968fe940766633e85.png" src="_images/85d93b13d95c473b274505e919877c6cd016e0c43438070968fe940766633e85.png" />
</div>
</div>
</section>
</section>
</section>
<section id="medidas">
<h2>Medidas<a class="headerlink" href="#medidas" title="Link para este cabeçalho">#</a></h2>
<p>Após realizar os cálculos na computação quântica, é necessário extrair os resultados para o ambiente clássico. Isso é feito por meio de medidas nos qubits. Nesta seção, exploraremos diferentes formas de medir qubits no Ket.</p>
<section id="extrair-o-estado-quantico">
<h3>Extrair o Estado Quântico<a class="headerlink" href="#extrair-o-estado-quantico" title="Link para este cabeçalho">#</a></h3>
<p>Ao simularmos um computador quântico, como fazemos neste capítulo, não estamos restritos às limitações da mecânica quântica. Assim, podemos extrair todo o estado quântico do simulador para manipulá-lo dentro do Python. Para isso, utilizamos a função <a class="reference external" href="https://quantumket.org/ket/api/ket.operations.html#ket.operations.dump" title="(em Ket Quantum Programming)"><code class="xref py py-func docutils literal notranslate"><span class="pre">dump()</span></code></a>, que retorna uma instância de <code class="xref py py-class docutils literal notranslate"><span class="pre">QuantumState</span></code>.</p>
<p>Com o objeto <code class="xref py py-class docutils literal notranslate"><span class="pre">QuantumState</span></code>, é possível iterar sobre o estado quântico usando o atributo <code class="xref py py-attr docutils literal notranslate"><span class="pre">states</span></code>. Neste atributo, o estado quântico é representado por um dicionário que mapeia o estado da base, representado por um número inteiro (<a class="reference external" href="https://docs.python.org/pt-br/3.10/library/functions.html#int" title="(em Python v3.10)"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>), para sua amplitude de probabilidade associada, representada por um número complexo (<a class="reference external" href="https://docs.python.org/pt-br/3.10/library/functions.html#complex" title="(em Python v3.10)"><code class="xref py py-class docutils literal notranslate"><span class="pre">complex</span></code></a>).</p>
<div class="admonition warning">
<p class="admonition-title">Aviso</p>
<p>A extração do <code class="xref py py-class docutils literal notranslate"><span class="pre">QuantumState</span></code> só é possível quando estamos em um ambiente simulado. Além disso, o <code class="xref py py-class docutils literal notranslate"><span class="pre">QuantumState</span></code> não tem a capacidade de representar estados mistos. Portanto, se o <code class="xref py py-class docutils literal notranslate"><span class="pre">QuantumState</span></code> representar um qubit entrelaçado com um qubit que não pertence ao mesmo <code class="xref py py-class docutils literal notranslate"><span class="pre">QuantumState</span></code>, a representação não será completa.</p>
<p>Tendo isso em mente, o uso da função <a class="reference external" href="https://quantumket.org/ket/api/ket.operations.html#ket.operations.dump" title="(em Ket Quantum Programming)"><code class="xref py py-func docutils literal notranslate"><span class="pre">dump()</span></code></a> é uma ótima maneira de testar e debugar uma execução quântica. No entanto, não é recomendado substituir uma medida por esta abordagem.</p>
</div>
<p>Além do atributo <code class="xref py py-attr docutils literal notranslate"><span class="pre">states</span></code>, é possível acessar o atributo <code class="xref py py-attr docutils literal notranslate"><span class="pre">probabilities</span></code> para obter as probabilidades de medida. Também podemos utilizar o método <code class="xref py py-meth docutils literal notranslate"><span class="pre">sample()</span></code> para simular uma amostragem a partir do <code class="xref py py-class docutils literal notranslate"><span class="pre">QuantumState</span></code>.</p>
<p>Abaixo, seguem exemplos de como utilizar a função <a class="reference external" href="https://quantumket.org/ket/api/ket.operations.html#ket.operations.dump" title="(em Ket Quantum Programming)"><code class="xref py py-func docutils literal notranslate"><span class="pre">dump()</span></code></a> para extrair o estado quântico e iterar sobre ele através do atributo <code class="xref py py-attr docutils literal notranslate"><span class="pre">states</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">processo</span> <span class="o">=</span> <span class="n">Process</span><span class="p">()</span>

<span class="n">qubits</span> <span class="o">=</span> <span class="n">processo</span><span class="o">.</span><span class="n">alloc</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

<span class="c1"># prepara estado de Bell</span>
<span class="n">cat</span><span class="p">(</span><span class="n">kron</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">I</span><span class="p">),</span> <span class="n">CNOT</span><span class="p">)(</span><span class="o">*</span><span class="n">qubits</span><span class="p">)</span>

<span class="n">estado_quântico</span> <span class="o">=</span> <span class="n">dump</span><span class="p">(</span><span class="n">qubits</span><span class="p">)</span>

<span class="k">for</span> <span class="n">estado</span><span class="p">,</span> <span class="n">amplitude</span> <span class="ow">in</span> <span class="n">estado_quântico</span><span class="o">.</span><span class="n">states</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">amplitude</span><span class="si">}</span><span class="s2"> |</span><span class="si">{</span><span class="n">estado</span><span class="si">}</span><span class="s2">⟩&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(0.7071067811865476+0j) |0⟩
(0.7071067811865476+0j) |3⟩
</pre></div>
</div>
</div>
</div>
<p>Uma maneira alternativa de exibir o estado quântico é utilizando o método <code class="xref py py-meth docutils literal notranslate"><span class="pre">show()</span></code> da classe <code class="xref py py-class docutils literal notranslate"><span class="pre">QuantumState</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">estado_quântico</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_latex math notranslate nohighlight">
\[\displaystyle \frac{1}{\sqrt{2}} \left|00\right&gt;+\frac{1}{\sqrt{2}} \left|11\right&gt;\]</div>
</div>
</div>
</section>
<section id="medicao-de-qubits">
<h3>Medição de Qubits<a class="headerlink" href="#medicao-de-qubits" title="Link para este cabeçalho">#</a></h3>
<p>A função <a class="reference external" href="https://quantumket.org/ket/api/ket.operations.html#ket.operations.measure" title="(em Ket Quantum Programming)"><code class="xref py py-func docutils literal notranslate"><span class="pre">measure()</span></code></a> é utilizada para medir qubits na base computacional, resultando em um objeto do tipo <a class="reference external" href="https://quantumket.org/ket/api/ket.base.html#ket.base.Measurement" title="(em Ket Quantum Programming)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Measurement</span></code></a>. Após a medição, o estado do qubit colapsa para o estado correspondente à medida realizada. Para extrair o resultado da medida, basta acessar o atributo <a class="reference external" href="https://quantumket.org/ket/api/ket.base.html#ket.base.Measurement.value" title="(em Ket Quantum Programming)"><code class="xref py py-attr docutils literal notranslate"><span class="pre">value</span></code></a>, o qual retorna um número inteiro sem sinal. É importante observar que o qubit de índice 0 corresponde ao bit de maior magnitude no resultado final. Portanto, a medição dos qubits <span class="math notranslate nohighlight">\(\ket{\texttt{xyz}}\)</span> resulta no número binário <span class="math notranslate nohighlight">\(\texttt{0b}\texttt{xyz}\)</span>.</p>
<p>Abaixo está um exemplo de uso da função <a class="reference external" href="https://quantumket.org/ket/api/ket.operations.html#ket.operations.measure" title="(em Ket Quantum Programming)"><code class="xref py py-func docutils literal notranslate"><span class="pre">measure()</span></code></a>. Neste exemplo, estamos medindo o primeiro qubit após a preparação do estado de Bell e exibindo o resultado da medida.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">processo</span> <span class="o">=</span> <span class="n">Process</span><span class="p">()</span>

<span class="n">qubits</span> <span class="o">=</span> <span class="n">processo</span><span class="o">.</span><span class="n">alloc</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

<span class="c1"># Preparando o estado de Bell</span>
<span class="n">cat</span><span class="p">(</span><span class="n">kron</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">I</span><span class="p">),</span> <span class="n">CNOT</span><span class="p">)(</span><span class="o">*</span><span class="n">qubits</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Estado quântico antes da medida&quot;</span><span class="p">)</span>
<span class="n">display</span><span class="p">(</span><span class="n">dump</span><span class="p">(</span><span class="n">qubits</span><span class="p">)</span><span class="o">.</span><span class="n">show</span><span class="p">())</span>

<span class="n">medida</span> <span class="o">=</span> <span class="n">measure</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Resultado da medida do primeiro qubit:&quot;</span><span class="p">,</span> <span class="n">medida</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Estado quântico após o colapso&quot;</span><span class="p">)</span>
<span class="n">display</span><span class="p">(</span><span class="n">dump</span><span class="p">(</span><span class="n">qubits</span><span class="p">)</span><span class="o">.</span><span class="n">show</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Estado quântico antes da medida
</pre></div>
</div>
<div class="output text_latex math notranslate nohighlight">
\[\displaystyle \frac{1}{\sqrt{2}} \left|00\right&gt;+\frac{1}{\sqrt{2}} \left|11\right&gt;\]</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Resultado da medida do primeiro qubit: 0
Estado quântico após o colapso
</pre></div>
</div>
<div class="output text_latex math notranslate nohighlight">
\[\displaystyle  \left|00\right&gt;\]</div>
</div>
</div>
<section id="exercicio-medidas-em-outras-bases">
<h4>Exercício: Medidas em Outras Bases<a class="headerlink" href="#exercicio-medidas-em-outras-bases" title="Link para este cabeçalho">#</a></h4>
<p>Os computadores quânticos normalmente realizam medidas apenas na base computacional (base Z). No entanto, aplicando algumas operações quânticas, é possível realizar medidas em outras bases. Neste exercício, exploraremos medidas nas bases X e Y.</p>
<p><strong>Medidas na Base X (Hadamard):</strong></p>
<p>Na base X, também conhecida como base de Hadamard, a medida de um qubit no estado <span class="math notranslate nohighlight">\(\frac{1}{\sqrt{2}}(\ket{0}+\ket{1})\)</span> retorna 0, e a medida no estado <span class="math notranslate nohighlight">\(\frac{1}{\sqrt{2}}(\ket{0}-\ket{1})\)</span> retorna 1. Implemente as rotações necessárias nos qubits para efetuar uma medida na base computacional usando a função <a class="reference external" href="https://quantumket.org/ket/api/ket.operations.html#ket.operations.measure" title="(em Ket Quantum Programming)"><code class="xref py py-func docutils literal notranslate"><span class="pre">measure()</span></code></a>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">medir_x</span><span class="p">(</span><span class="n">qubit</span><span class="p">:</span> <span class="n">Quant</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span> <span class="o">...</span>


<span class="k">def</span><span class="w"> </span><span class="nf">verificar_medir_x</span><span class="p">():</span>
    <span class="n">processo</span> <span class="o">=</span> <span class="n">Process</span><span class="p">()</span>

    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">processo</span><span class="o">.</span><span class="n">alloc</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">X</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="n">H</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span>

    <span class="k">assert</span> <span class="n">medir_x</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
    <span class="k">assert</span> <span class="n">medir_x</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Verificação concluída com sucesso&quot;</span><span class="p">)</span>


<span class="c1"># verificar_medir_x()</span>
</pre></div>
</div>
</div>
</div>
<p><strong>Medidas na Base Y:</strong></p>
<p>Na base Y, a medida de um qubit no estado <span class="math notranslate nohighlight">\(\frac{1}{\sqrt{2}}(\ket{0}+i\ket{1})\)</span> retorna 0, e a medida no estado <span class="math notranslate nohighlight">\(\frac{1}{\sqrt{2}}(\ket{0}-i\ket{1})\)</span> retorna 1. Implemente as rotações necessárias nos qubits para efetuar uma medida na base computacional usando a função <a class="reference external" href="https://quantumket.org/ket/api/ket.operations.html#ket.operations.measure" title="(em Ket Quantum Programming)"><code class="xref py py-func docutils literal notranslate"><span class="pre">measure()</span></code></a>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">medir_y</span><span class="p">(</span><span class="n">qubit</span><span class="p">:</span> <span class="n">Quant</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span> <span class="o">...</span>


<span class="k">def</span><span class="w"> </span><span class="nf">verificar_medir_y</span><span class="p">():</span>
    <span class="n">processo</span> <span class="o">=</span> <span class="n">Process</span><span class="p">()</span>

    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">processo</span><span class="o">.</span><span class="n">alloc</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">X</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="n">S</span><span class="p">(</span><span class="n">H</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">))</span>

    <span class="k">assert</span> <span class="n">medir_y</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
    <span class="k">assert</span> <span class="n">medir_y</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Verificação concluída com sucesso&quot;</span><span class="p">)</span>


<span class="c1"># verificar_medir_y()</span>
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="amostragem-de-qubits">
<h3>Amostragem de Qubits<a class="headerlink" href="#amostragem-de-qubits" title="Link para este cabeçalho">#</a></h3>
<p>Muitos algoritmos quânticos dependem não apenas de uma medida exata, mas de uma distribuição de probabilidades. Portanto, é necessário executar várias medições em vez de apenas uma. Muitos computadores quânticos implementam esse comportamento, e o Ket oferece a função <a class="reference external" href="https://quantumket.org/ket/api/ket.operations.html#ket.operations.sample" title="(em Ket Quantum Programming)"><code class="xref py py-func docutils literal notranslate"><span class="pre">sample()</span></code></a>, que retorna uma instância de <a class="reference external" href="https://quantumket.org/ket/api/ket.base.html#ket.base.Samples" title="(em Ket Quantum Programming)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Samples</span></code></a> com os resultados das medições. Para acessar o resultado, basta ler o atributo <a class="reference external" href="https://quantumket.org/ket/api/ket.base.html#ket.base.Samples.value" title="(em Ket Quantum Programming)"><code class="xref py py-attr docutils literal notranslate"><span class="pre">value</span></code></a>, que retorna um dicionário mapeando o estado medido ao número de vezes que esse estado foi observado.</p>
<div class="admonition attention">
<p class="admonition-title">Atenção</p>
<p>Nos simuladores padrão do Ket o estado quântico não é colapsado após a chamada da função <a class="reference external" href="https://quantumket.org/ket/api/ket.operations.html#ket.operations.sample" title="(em Ket Quantum Programming)"><code class="xref py py-func docutils literal notranslate"><span class="pre">sample()</span></code></a>, e os qubits permanecem disponíveis para outras operações. No entanto, esse comportamento não é garantido em computadores quânticos reais, onde os qubits normalmente se tornam indisponíveis após a medição.</p>
</div>
<p>A seguir, apresentamos um exemplo de uso da função <a class="reference external" href="https://quantumket.org/ket/api/ket.operations.html#ket.operations.sample" title="(em Ket Quantum Programming)"><code class="xref py py-func docutils literal notranslate"><span class="pre">sample()</span></code></a>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">processo</span> <span class="o">=</span> <span class="n">Process</span><span class="p">()</span>

<span class="n">qubits</span> <span class="o">=</span> <span class="n">processo</span><span class="o">.</span><span class="n">alloc</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

<span class="c1"># Preparando o estado de Bell</span>
<span class="n">cat</span><span class="p">(</span><span class="n">kron</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">I</span><span class="p">),</span> <span class="n">CNOT</span><span class="p">)(</span><span class="o">*</span><span class="n">qubits</span><span class="p">)</span>

<span class="n">estado_quântico</span> <span class="o">=</span> <span class="n">dump</span><span class="p">(</span><span class="n">qubits</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Estado quântico&quot;</span><span class="p">)</span>
<span class="n">display</span><span class="p">(</span><span class="n">dump</span><span class="p">(</span><span class="n">qubits</span><span class="p">)</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="s2">&quot;i&quot;</span><span class="p">))</span>

<span class="n">medida</span> <span class="o">=</span> <span class="n">sample</span><span class="p">(</span><span class="n">qubits</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Resultado das medidas:&quot;</span><span class="p">,</span> <span class="n">medida</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Estado quântico
</pre></div>
</div>
<div class="output text_latex math notranslate nohighlight">
\[\displaystyle \frac{1}{\sqrt{2}} \left|0\right&gt;+\frac{1}{\sqrt{2}} \left|3\right&gt;\]</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Resultado das medidas: {0: 1035, 3: 1013}
</pre></div>
</div>
</div>
</div>
</section>
<section id="calcular-valor-esperado">
<h3>Calcular Valor Esperado<a class="headerlink" href="#calcular-valor-esperado" title="Link para este cabeçalho">#</a></h3>
</section>
</section>
<section id="execucao-quantica-e-simulacao">
<h2>Execução Quântica e Simulação<a class="headerlink" href="#execucao-quantica-e-simulacao" title="Link para este cabeçalho">#</a></h2>
<section id="modos-de-execucao-quantica">
<h3>Modos de Execução Quântica<a class="headerlink" href="#modos-de-execucao-quantica" title="Link para este cabeçalho">#</a></h3>
</section>
<section id="configuracao-do-processo-e-dos-simuladores">
<h3>Configuração do Processo e dos Simuladores<a class="headerlink" href="#configuracao-do-processo-e-dos-simuladores" title="Link para este cabeçalho">#</a></h3>
</section>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "evandro-crr/ket-book",
            ref: "main",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="07-computacao_quantica.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">anterior</p>
        <p class="prev-next-title">Computação Quântica</p>
      </div>
    </a>
    <a class="right-next"
       href="09-algoritmos.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">próximo</p>
        <p class="prev-next-title">Algoritmos Quânticos</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Conteúdo
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#introducao">Introdução</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#instalacao">Instalação</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#documentacao">Documentação</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#importando-o-ket">Importando o Ket</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#processo-quantico">Processo Quântico</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#alocacao-de-qubits">Alocação de Qubits</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#portas-logicas-quanticas">Portas Lógicas Quânticas</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#portas-de-1-qubit">Portas de 1 Qubit</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#portas-de-pauli-e-de-hadamard">Portas de Pauli e de Hadamard</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#portas-parametrizadas">Portas Parametrizadas</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#concatenando-portas-quanticas">Concatenando Portas Quânticas</a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#encadeamento-de-chamadas-de-funcao">Encadeamento de chamadas de função</a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#concatenacao-de-portas">Concatenação de portas</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#portas-de-2-qubits">Portas de 2 Qubits</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#produto-tensorial-de-portas">Produto Tensorial de Portas</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#instrucoes-quanticas">Instruções Quânticas</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#operacoes-controladas">Operações Controladas</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#exercicio-implementando-o-estado-ghz">Exercício: Implementando o Estado GHZ</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#operacoes-inversas">Operações Inversas</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#operacoes-uvu-dagger">Operações <span class="math notranslate nohighlight">\(UVU^\dagger\)</span></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#alterando-o-estado-de-controle">Alterando o Estado de Controle</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#exercicio-implementando-portas-quanticas-com-with-around">Exercício: Implementando Portas Quânticas com <code class="docutils literal notranslate"><span class="pre">with</span> <span class="pre">around</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#medidas">Medidas</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#extrair-o-estado-quantico">Extrair o Estado Quântico</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#medicao-de-qubits">Medição de Qubits</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#exercicio-medidas-em-outras-bases">Exercício: Medidas em Outras Bases</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#amostragem-de-qubits">Amostragem de Qubits</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#calcular-valor-esperado">Calcular Valor Esperado</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#execucao-quantica-e-simulacao">Execução Quântica e Simulação</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#modos-de-execucao-quantica">Modos de Execução Quântica</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#configuracao-do-processo-e-dos-simuladores">Configuração do Processo e dos Simuladores</a></li>
</ul>
</li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
De Evandro Chagas Ribeiro da Rosa
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2024.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>