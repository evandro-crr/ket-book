

\chapter{\nohyphens{Elementos de Computação Clássica}}\label{cap1_comp_classica}



\begin{section}{Introdução}

\indent Um computador digital é um sistema que pode seguir uma sequência de instruções, chamada programa, e que opera em um conjunto de informações. Os computadores digitais modernos são compostos de milhões a bilhões de transistores, que se agrupam em circuitos digitais. Para lidar com a complexidade desses sistemas, os circuitos são subdivididos em circuitos menores, que realizam funções específicas. Esses circuitos são considerados ``caixas pretas'', em que se ignoram os detalhes internos, e são agrupados de forma a realizar funções mais sofisticadas. 

A engenharia trabalha com \emph{níveis de abstração}; cada nível corresponde a omitir detalhes internos dos subsistemas constituíntes, ou da camada de abstração anterior. Uma discussão mais detalhada sobre as camadas de abstração do computador será realizada na seção seguinte. 

Para que o computador consiga operar em um conjunto de informações, é necessário que essa informação seja traduzida, ou, codificada, de forma conveniente. O projeto dos computadores digitais se baseia em que as informações de entrada do sistema, e mesmo as instruções a serem seguidas, são codificadas em \emph{bits}. 

Os bits são variáveis que podem assumir apenas dois valores, rotulados de 0/1 ou Verdadeiro/Falso, por exemplo. No computador digital, a tensão elétrica é utilizada como bit; as tensões próximas a $0V$ são consideradas como bit 0 e as tensões próximas à tensão de alimentação do circuito (normalmente $5V$ ou $3,\!3V$), como bit 1. 

Nas seções seguintes alguns desses tópicos serão detalhados. A ênfase será nas ideias vinculadas aos Sistemas Digitais, no manejo da complexidade por meio das camadas de abstração e nos detalhes das camadas mais próximas da camada física, com o objetivo de passar a ideia de como um computador digital clássico funciona. A finalidade é, também, comparar esse paradigma de computação com as ideias que estão surgindo na área da Computação Quântica. As principais referências dessa seção são os livros \cite{book:lcdf_mkm}, \cite{book:ds_tocci} e \cite{book:dd_vahid} de Sistemas Digitais e o livro \cite{book:cod_patterson} de Organização de Computadores. 

 
\end{section}

\begin{section}{Níveis de Abstração}

\indent Na engenharia, uma maneira de lidar com a complexidade de sistemas muito grandes é subdividí-los em subsistemas que possam ser descritos de maneira mais simples, omitindo detalhes internos. Componentes mais básicos são usados para projetar blocos que realizam funções simples. Esses blocos passam a ser descritos apenas pela sua função (como as saídas se comportam em relação às entradas), e passa-se a ignorar sua estrutura interna. Sistemas mais complexos podem ser projetados por meio desses blocos. A cada vez que se agrupa os sistemas em blocos e passa-se a ignorar sua estrutura interna, sobe-se um nível nas \emph{camadas de abstração}. Quando se ``abre'' um sistema para analisar sua estrutura interna, passa-se à camada de abstração inferior. 

Essa divisão em camadas de abstração permite que os diversos blocos do sistema sejam projetados de forma paralela. Além disso, o projeto de um bloco pode ser reaproveitado em outros momentos, no mesmo projeto ou em outros. Outra vantagem é que o sistema passa a ser visto como composto de uma quantidade relativamente pequena de subsistemas, em vez de ser visto como milhões de transistores, cujo funcionamento em conjunto seria virtualmente impossível de descrever diretamente. 

A figura a seguir ilustra as camadas de abstração presentes no computador digital. Dependendo do autor, as camadas de abstração são nomeadas de maneira ligeiramente diferente ou são consideradas algumas subcamadas extra. Neste trabalho, a nomenclatura e as camadas de abstração consideradas seguirão a referência \cite{book:lcdf_mkm}. 

\begin{table}[H]
 \centering
 \begin{tabular}{cc}

\begin{tabular}{cc}
  Níveis de Abstração
   &
  \begin{tikzpicture}[>=stealth]
  \draw[thick][->] (0,0) -- (0,3) ;
  
  \end{tikzpicture}
  \end{tabular}
  &
 \begin{tabular}{|c|c|}
 \hline
  Linguagens de Programação & \\
  Sistemas Operacionais & \\
  Instruction Set Architecture  & Nível Lógico\\
  Microarquitetura & \\
  Transferência de Registrador & \\
  Portas Lógicas & \\ \hline
  Circuitos Transistorizados & Nível Físico\\ \hline
 \end{tabular}
 \end{tabular}
\caption{Níveis de abstração -- um método útil para lidar com a complexidade de sistemas. As camadas de baixo são mais próximas do nível físico e as de cima são mais abstratas. Fonte: \cite{book:lcdf_mkm} (adaptado)}
\end{table}

\end{section}

\begin{section}{Nível Lógico}\label{cap1:sec_nivel_logico}
\indent O nível lógico refere-se à camada de abstração imediatamente acima da dos transistores. Os transistores são reunidos em \emph{portas lógicas}. Nessa camada de abstração, os sinais de tensão na entrada e na saída são interpretados como bits, e as portas lógicas que operam esses bits simulam as funções lógicas como OR, AND, NOT, entre outras.

Nesse agrupamento em blocos os detalhes internos do circuito são ignorados. 

\begin{subsection}{Álgebra Booleana}
 \indent As \emph{variáveis booleanas} são variáveis que podem assumir apenas dois valores, rotulados como 0/1 ou Falso/Verdadeiro. Os bits são sinônimos de variáveis booleanas. As funções $f\colon \{0,1\}^n \to \{0,1\}^m \,$, que levam um conjunto de $n$ bits em um conjunto de $m$ bits, são chamadas \emph{funções booleanas}. As funções booleanas podem ser especificadas por expressões matemáticas ou por uma tabela  -- a \emph{tabela verdade} -- listando todos os possíveis valores de entrada e a saída atribuída a cada valor de entrada. 
 
 Algumas funções booleanas elementares são chamadas de portas lógicas, ilustradas no tópico \ref{cap1:portas_logicas} subsequente. As três operações básicas da Álgebra Booleana são $+ \colon \{0,1\}^2 \to \{0,1\}$, $\cdot\, \colon \{0,1\}^2 \to \{0,1\}$ e $\overline{\phantom{a}} \colon \{0,1\} \to \{0,1\}$, também chamadas de operações OR, AND e NOT, respectivamente. 
 
 A Álgebra Booleana pode ser interpretada como descrição de um sistema lógico em que há apenas dois valores lógicos -- Falso/Verdadeiro ou 0/1 -- e às proposições lógicas pode ser atribuído um e apenas um desses valores devido ao princípio lógico elementar do terceiro excluído.
 % [Fonte: ftp://vm1-dca.fee.unicamp.br/pub/docs/vonzuben/ia861_1s10/notas_de_aula/topico3_IA861_1s10.pdf]
 
 Neste trabalho, o enfoque será mais voltado às aplicações em Sistemas Digitais. Um enfoque mais formal da álgebra booleana pode ser encontrado em \cite{book:iba_halmos}, capítulo 2, em que se define uma álgebra booleana de forma axiomática.
 
 
\end{subsection}

\begin{subsection}{Portas Lógicas}\label{cap1:portas_logicas}
 As portas lógicas são funções booleanas simples, blocos fundamentais dos circuitos digitais. As portas lógicas mais importantes são descritas resumidamente nas figuras a seguir. 
 
 \begin{comment}
Os símbolos que descrevem as portas lógicas, além de outros símbolos usados em sistemas digitais, são padronizados e especificados em detalhes no IEEE Standard 91-1984 [Institute of Electrical and Electronics Engineers'(IEEE) Standard Symbols for Logic Functions].
% Fonte: http://ieeexplore.ieee.org/servlet/opac?punumber=2405
 \end{comment}
 
\begin{comment}
 \begin{figure}[H]
\centering
\includegraphics[scale=0.4]{cap1/identity_gate.png}
\caption{Porta Identidade. Fonte: [Principles of Quantum Computation and Information, Vol 1. Basic Concepts, Benenti]}
\end{figure}
\end{comment}
 
 \begin{figure}[H]
\centering
\begin{tabular}{cccc}
 Nome & Símbolo & Equação & Tabela Verdade \\ \\
 NOT & \begin{tabular}{c} \\ \includegraphics[scale=0.4]{apA/figuras/not_gate.png}  \end{tabular}
 & $F = \overline{X}$ & \begin{tabular}{l|l} X & F \\ \hline 0 & 1 \\ 1 & 0 \end{tabular} \\
 \end{tabular}
\caption{Porta NOT.}
\end{figure}

 \begin{figure}[H]
\centering
\begin{tabular}{cccc}
 Nome & Símbolo & Equação & Tabela Verdade \\ \\
 AND & \begin{tabular}{c} \\ \includegraphics[scale=0.4]{apA/figuras/and_gate.png}  \end{tabular}
 & $F = X \cdot Y$ & \begin{tabular}{ll|l} X & Y & F \\ \hline 0 & 0 & 0 \\ 0 & 1 & 0 \\ 1 & 0 & 0 \\ 1 & 1 & 1 \end{tabular} 
 \end{tabular}
\caption{Porta AND.}
\end{figure}

 \begin{figure}[H]
\centering
\begin{tabular}{cccc}
 Nome & Símbolo & Equação & Tabela Verdade \\ \\
 OR & \begin{tabular}{c} \\ \includegraphics[scale=0.4]{apA/figuras/or_gate.png}  \end{tabular}
 & $F = X + Y$ &  \begin{tabular}{ll|l} X & Y & F \\ \hline 0 & 0 & 0 \\ 0 & 1 & 1 \\ 1 & 0 & 1 \\ 1 & 1 & 1 \end{tabular} \\
 \end{tabular}
\caption{Porta OR.}
\end{figure}

 \begin{figure}[H]
\centering
\begin{tabular}{cccc}
 Nome & Símbolo & Equação & Tabela Verdade \\ \\
 NAND & \begin{tabular}{c} \\ \includegraphics[scale=0.4]{apA/figuras/nand_gate.png}  \end{tabular}
 & $F = \overline{X \cdot Y}$ &  \begin{tabular}{ll|l} X & Y & F \\ \hline 0 & 0 & 1 \\ 0 & 1 & 1 \\ 1 & 0 & 1 \\ 1 & 1 & 0 \end{tabular} \\
 \end{tabular}
\caption{Porta NAND.}
\end{figure}

 \begin{figure}[H]
\centering
\begin{tabular}{cccc}
 Nome & Símbolo & Equação & Tabela Verdade \\ \\
 NOR & \begin{tabular}{c} \\ \includegraphics[scale=0.4]{apA/figuras/nor_gate.png}  \end{tabular}
 & $F = \overline{X + Y}$ &  \begin{tabular}{ll|l} X & Y & F \\ \hline 0 & 0 & 1 \\ 0 & 1 & 0 \\ 1 & 0 & 0 \\ 1 & 1 & 0 \end{tabular} \\
 \end{tabular}
\caption{Porta NOR.}
\end{figure}

 \begin{figure}[H]
\centering
\begin{tabular}{cccc}
 Nome & Símbolo & Equação & Tabela Verdade \\ \\
 XOR & \begin{tabular}{c} \\ \includegraphics[scale=0.4]{apA/figuras/xor_gate.png}  \end{tabular}
 & $F = X \oplus Y$ &  \begin{tabular}{ll|l} X & Y & F \\ \hline 0 & 0 & 0 \\ 0 & 1 & 1 \\ 1 & 0 & 1 \\ 1 & 1 & 0 \end{tabular} \\
 \end{tabular}
\caption{Porta XOR (exclusive-OR).}
\end{figure}

 \begin{figure}[H]
\centering
\begin{tabular}{cccc}
 Nome & Símbolo & Equação & Tabela Verdade \\ \\
 XNOR & \begin{tabular}{c} \\ \includegraphics[scale=0.4]{apA/figuras/xnor_gate.png}  \end{tabular}
 & $F =\overline{X \oplus Y}$ &  \begin{tabular}{ll|l} X & Y & F \\ \hline 0 & 0 & 1 \\ 0 & 1 & 0 \\ 1 & 0 & 0 \\ 1 & 1 & 1 \end{tabular} \\
 \end{tabular}
\caption{Porta XNOR (exclusive-NOR).}
\end{figure}

\begin{figure}[H]
\centering
\begin{tabular}{cccc}
 Nome & Símbolo & Tabela Verdade \\ \\
 FANOUT / COPY & \begin{tabular}{c} \\ \includegraphics[scale=0.35]{apA/figuras/fanout_copy_gate.png}  \end{tabular}
  &  \begin{tabular}{l|ll} X & F & G \\ \hline 0 & 0 & 0 \\ 1 & 1 & 1 \end{tabular} \\ \\
 CROSSOVER / SWAP & \begin{tabular}{c} \\ \includegraphics[scale=0.35]{apA/figuras/crossover_swap_gate.png}  \end{tabular}
  &  \begin{tabular}{ll|ll} X & Y & F & G \\ \hline 0 &0& 0 & 0 \\0 &1& 1 & 0 \\1 &0& 0 & 1 \\1 &1& 1 & 1 \\ \end{tabular} \\ \\
 \end{tabular}
\caption{Outras portas lógicas usadas implicitamente nos Sistemas Digitais: FANOUT / COPY e CROSSOVER / SWAP.}
\end{figure}

Qualquer sistema físico que se comporte de maneira a fornecer uma tabela verdade como as apresentadas acima pode ser considerado uma porta lógica. 

\end{subsection}

\begin{subsection}{Teoremas da Álgebra Booleana}
 
 Apresentam-se algumas identidades booleanas úteis para simplificação de expressões. 
 
 \begin{theorem}[Teoremas da Álgebra Booleana para uma variável]\label{cap1:thm_ab_1var}
 \ \\ Valem as seguintes identidades:\\
\[
 \begin{split}
  X \cdot 0  &= 0 \\
  X \cdot 1  &= X \\
  X \cdot X  &= X \\
  X \cdot \overline{X} &= 0
 \end{split} \quad \quad \quad
\begin{split}
 X + 0 &= X \\
 X + 1 &= 1 \\
 X + X &= X  \\
 X + \overline{X} &= 1 
\end{split}
\]

 \begin{comment}
   \begin{figure}[H]
\centering
\includegraphics[scale=0.4]{cap1/teoremas_algebra_booleana_uma_variavel.png}
\caption{Teoremas da Álgebra Booleana para uma variável.}
\end{figure}
  \end{comment}
 \end{theorem}
 
 \begin{proof}
  As igualdades se verificam testando todos os casos:
  \small
  \[ \begin{array}{lll}
   X \cdot 0 \, = 0 \, \, \, \,:  \begin{cases}
                         0\cdot 0 = 0 & (X=0) \\ 1\cdot 0 = 0  & (X=1)
                       \end{cases}
   & &
     X + 0 \, = 0 \, \, \, \, :  \begin{cases}
                       0 + 0 = 0 & (X=0)\\  1 + 0 = 1 & (X=1)
                       \end{cases} 
 \vspace{5pt} \\ 
  X \cdot 1 \, = X \, \, :  \begin{cases}
                         0\cdot 1 = 0 & (X=0) \\ 1\cdot 1 = 1  & (X=1)
                       \end{cases}
   & &
     X + 1 \, = 1 \, \, \, \, :  \begin{cases}
                       0 + 1 = 1 & (X=0)\\  1 + 1 = 1 & (X=1)
                       \end{cases} 
 \vspace{5pt} \\ 
  X \cdot X \, = X:  \begin{cases}
                         0\cdot 0 = 0 & (X=0) \\ 1\cdot 1 = 1  & (X=1)
                       \end{cases}
   & &
     X + X \, = X :  \begin{cases}
                       0 + 0 = 0 & (X=0)\\  1 + 1 = 1 & (X=1)
                       \end{cases} 
 \vspace{5pt} \\ 
  X \cdot \overline{X} \, = 0 \, \, :  \begin{cases}
                         0\cdot 1 = 0 & (X=0) \\ 1\cdot 0 = 0  & (X=1)
                       \end{cases}
   & &
     X + \overline{X} \, = 1 \, \, :  \begin{cases}
                       0 + 1 = 1 & (X=0)\\  1 + 0 = 1 & (X=1)
                       \end{cases} 
  \end{array} \]
  \normalsize
 \end{proof}


\begin{theorem}[Teoremas da Álgebra Booleana para várias variáveis]
\ \\
Valem as seguintes identidades:
\[ \begin{array}{ll}
   \bigstrut \text{Associatividade} & 
    \begin{array}{l}
    X + (Y + Z) = (X + Y) + Z \\
    (XY)Z = X(YZ) 
   \end{array} 
   \vspace{4pt} \\
   \bigstrut \text{Comutatividade} &
   \begin{array}{l}
    X + Y = Y + X \\
    X Y = YX 
   \end{array} 
    \vspace{4pt} \\
   \bigstrut \text{Distributividade} &
   \begin{array}{l}
    X (Y+Z) = XY + XZ \\
    (X+Y)Z = XZ + YZ \\
    (X+Y)(Z+W) = XZ + XW + YZ + YW 
   \end{array} 
    \vspace{4pt} \\
   \bigstrut \text{Outras} &
   \begin{array}{l}
    X + XY = X\\
    X + \overline{X}Y = X+Y \\
    \overline{X} + XY = \overline{X} + Y
   \end{array} 
   \end{array} \]



\begin{comment}
 \begin{figure}[H]
\centering
\includegraphics[scale=0.6]{cap1/teoremas_algebra_booleana_varias_variaveis.png}
\caption{Teoremas da Álgebra Booleana para várias variáveis.}
\end{figure}
\end{comment}
\end{theorem}

\begin{proof}
 A verificação se dá atribuindo valores às variáveis ou escrevendo a tabela verdade dos dois lados da equação e verificando que o resultado é o mesmo. Pode-se usar o teorema \ref{cap1:thm_ab_1var} para facilitar. Por exemplo, verifica-se a identidade do $X (Y+Z) = XY + XZ $: \\
 Para $X=0$: \ \ $0(Y+Z) = 0 = 0Y + 0Z$. \\
 Para $X=1$: \ \ $1(Y+Z) = Y+Z = 1Y + 1Z$.
\end{proof}


 \begin{theorem}[Teoremas DeMorgan]
 \ \\
 Valem as seguintes identidades booleanas:
 \[ \begin{split}
     \overline{X + Y} &= \overline{X} \cdot \overline{Y} \\
     \overline{X \cdot Y} &= \overline{X} + \overline{Y}
    \end{split} \]
\begin{comment}
\begin{figure}[H]
\centering
\includegraphics[scale=0.6]{cap1/teoremas_de_morgan.png}
\caption{Teoremas de DeMorgan.}
\end{figure}
\end{comment}
 \end{theorem}

 \begin{proof}
  \ \\
  Mostrando $  \overline{X + Y} = \overline{X} \cdot \overline{Y}$:
  \[ \begin{array}{cc|cc|ccc}
    X & Y & X+Y & \overline{X + Y} & \overline{X} & \overline{Y} & \overline{X} \cdot \overline{Y} \\ \hline
    0 & 0 & 0   & 1 & 1 & 1 & 1 \\
    0 & 1 & 1   & 0 & 1 & 0 & 0 \\
    1 & 0 & 1   & 0 & 0 & 1 & 0 \\
    1 & 1 & 1   & 0 & 0 & 0 & 0 
  \end{array} \]
  Os valores das colunas $\overline{X + Y}$ e $\overline{X} \cdot \overline{Y}$ coincidem, portanto vale a igualdade. \vspace{2pt} \\
    Mostrando $  \overline{X \cdot Y} = \overline{X} + \overline{Y}$:
  \[ \begin{array}{cc|cc|ccc}
    X & Y & X\cdot Y & \overline{X \cdot Y} & \overline{X} & \overline{Y} & \overline{X} + \overline{Y} \\ \hline
    0 & 0 & 0   & 1 & 1 & 1 & 1 \\
    0 & 1 & 0   & 1 & 1 & 0 & 1 \\
    1 & 0 & 0   & 1 & 0 & 1 & 1 \\
    1 & 1 & 1   & 0 & 0 & 0 & 0 
  \end{array} \]
  Como os valores das colunas $\overline{X \cdot Y}$ e $\overline{X} + \overline{Y}$ coincidem, igualdade é válida.
 \end{proof}

 



\end{subsection}

\begin{subsection}{Universalidade das Portas Lógicas Clássicas}\label{cap1:universalidade_portas_logicas_classicas}

 Com apenas algumas das portas lógicas apresentadas em \ref{cap1:portas_logicas} pode-se compor qualquer função booleana. 
 
 \begin{theorem}[Universalidade das portas OR, AND e NOT]\label{cap1:teorema_universalidade_or_and_not}
   \ \\   
   Uma função booleana $f \colon \{0,1\}^m \to \{0,1\}^n$ qualquer pode ser implementada por uma composição das portas lógicas OR, AND e NOT (além das portas SWAP e FANOUT).
 \end{theorem}

 \begin{proof}

  
  Considere uma função booleana $f \colon \{0,1\}^m \to \{0,1\}^n$ qualquer. Basta fazer a demonstração para $n=1$. Considerando que esse caso já esteja demonstrado, e visto que pode-se usar a porta FANOUT para copiar cada uma das $m$ entradas o número de vezes que for necessário, pode-se implementar todas as $n$ funções que retornam apenas 1 bit: $f_i \colon\{0,1\}^m \to \{0,1\}$, $i=1, 2 \ldots, n$. O caso analisado será, então, o de uma função que retorna apenas $n=1$ bit na saída.

   Considere a seguinte notação. O vetor de bits $(A_0 , A_1 , \dots , A_{m-1})$, que se pode representar pela justaposição $A_0 A_1 \dots A_{m-1}$, pode assumir os $2^m$ valores $0\dots 00$, $0\dots 01$, até $1 \dots 11$. Esses vetores podem ser identificados com a representação de números inteiros sem sinal na base $2$ conforme ilustra a tabela abaixo.
   
   \begin{table}[h]
    \centering
    \begin{tabular}{r|r}
    $A_0 A_1 \dots A_{m-1}$ & Número inteiro   \\ 
    \hline                           
    $0 \dots 00$ & $0\cdot 2^{m-1} + \dots + 0 \cdot 2^1 + 0 \cdot 2^0 = \phantom{2^m -}  \ 0 $   \\
    $0 \dots 01$ & $0\cdot 2^{m-1} + \dots + 0 \cdot 2^1 + 1 \cdot 2^0 = \phantom{2^m -}  \ 1 $   \\
    $0 \dots 10$ & $0\cdot 2^{m-1} + \dots + 1 \cdot 2^1 + 0 \cdot 2^0 =  \phantom{2^m -} \ 2$   \\
    $0 \dots 11$ & $0\cdot 2^{m-1} + \dots + 1 \cdot 2^1 + 1 \cdot 2^0 =  \phantom{2^m -} \  3$   \\
    $\vdots \quad  $ & $\vdots \quad \quad \quad \  $ \\
    $1 \dots 11$ & $1\cdot 2^{m-1} + \dots + 1 \cdot 2^1 + 1 \cdot 2^0 = 2^m -1$ 
    \end{tabular}
    \caption{Correspondência entre vetor de bits $A_0 A_1 \dots A_{m-1}$ e o subconjunto de números inteiros sem sinal $\{ 0, 1, 2, \dots, 2^m-1\}$. }
    \label{cap1:tab_vetor_bits_representacao_nros_inteiros}
    \end{table}
   
   Com essa correspondência, passa-se a identificar o vetor de bits com o número inteiro sem sinal associado. Dessa forma, pode-se denotar $f(0 \dots 1 1)$ por $f(3)$, por exemplo. 
   
   Seja $m_i \colon \{0,1\}^m \to \{0,1\}$, com $i=0, 1, \dots, (2^n-1)$, dada por $m_i (i) = 1$ e $m_i(j) = 0$ se $i\neq j$. Essas funções são chamadas \emph{minitermos}, e assumem o valor $1$ para exatamente um vetor de bits de entrada. 
   
   Seja $I = \{ i \colon f(i) = 1 \}$ o conjunto de entradas em que $f$ assume o valor $1$. Pode-se decompor $f$ como a soma (OR) abaixo:
   \[ f = \sum_{i \in I} m_i \, .\]
   Essa soma adquire valor 1 exatamente quando algum dos minitermos $m_i$ assume 1. Como os minitermos considerados são os associados às entradas em que $f$ assume o valor 1, a soma assume 1 exatamente nas mesmas entradas em que $f$ assume o valor 1.
   
     \begin{figure}[H]
    \centering
    \[ 
    \begin{array}{c|ccc|c}
      & A & B & C & f \\ \hline
    0 & 0 & 0 & 0 & 0 \\
    1 & 0 & 0 & 1 & 0 \\
    2 & 0 & 1 & 0 & 1 \\
    3 & 0 & 1 & 1 & 0 \\
    4 & 1 & 0 & 0 & 1 \\
    5 & 1 & 0 & 1 & 0 \\
    6 & 1 & 1 & 0 & 0 \\
    7 & 1 & 1 & 1 & 1 
    \end{array} \quad \quad \quad
    \begin{array}{c|ccc|ccc}
      & A & B & C & m_2 & m_4 & m_7 \\ \hline
    0 & 0 & 0 & 0 & 0 & 0 & 0  \\
    1 & 0 & 0 & 1 & 0 & 0 & 0  \\
    2 & 0 & 1 & 0 & 1 & 0 & 0  \\
    3 & 0 & 1 & 1 & 0 & 0 & 0  \\
    4 & 1 & 0 & 0 & 0 & 1 & 0  \\
    5 & 1 & 0 & 1 & 0 & 0 & 0  \\
    6 & 1 & 1 & 0 & 0 & 0 & 0  \\
    7 & 1 & 1 & 1 & 0 & 0 & 1  
    \end{array}
    \]
    Portanto: $f = m_2 + m_4 + m_7$
    % \includegraphics[scale=0.2]{cap1/tabela_exemplo_1.png}
    \caption{Exemplo: $m=3$ bits e decomposição de $f$.}
    \end{figure}
    
    Mas cada minitermo $m_i$ pode, por sua vez, ser implementado com portas AND e NOT da seguinte forma. Considere $i$ fixo e seja $i = A_0 A_1 \dots A_{m-1}$, conforme a notação adotada. Alguns desses $m$ bits assumem valor $0$ e o restante, o valor $1$. Denote por $A_k$ os bits que assumem valor $0$ e $A_l$ os bits que assumem o valor $1$, para certos conjuntos de índices $K$ e $L$. 
    
    Agora seja $j = B_0 B_1 \dots B_{m-1}$, que fará papel da entrada da função $m_i$. Considere o produto (AND) abaixo:
    \[ \prod_{k \in K} \overline{B_k}  \cdot \prod_{l \in L} B_l \]
    Essa função assume o valor 1 apenas quando todos os termos do produto (AND) valem 1. Isso ocorre apenas para $j=i$, isto é, para $A_0 = B_0, \ldots, A_{m-1}=B_{m-1}$. Portanto:
    \[ \prod_{k \in K} \overline{B_k}  \cdot \prod_{l \in L} B_l = m_i(B_0\ldots B_{m-1}) \, . \]
    
     \begin{figure}[H]
    \[ 
      \begin{array}{c|ccc|ccc|c}
      & A & B & C & \overline{A} & B & \overline{C} & \overline{A}B\overline{C} \\ \hline
    0 & 0 & 0 & 0 & 1 & 0 & 1  & 0 \\
    1 & 0 & 0 & 1 & 1 & 0 & 0  & 0 \\
    2 & 0 & 1 & 0 & \boxed{1} & \boxed{1} & \boxed{1}  & \boxed{1} \\
    3 & 0 & 1 & 1 & 1 & 1 & 0  & 0 \\
    4 & 1 & 0 & 0 & 0 & 0 & 1  & 0 \\
    5 & 1 & 0 & 1 & 0 & 0 & 0  & 0 \\
    6 & 1 & 1 & 0 & 0 & 1 & 1  & 0 \\
    7 & 1 & 1 & 1 & 0 & 1 & 0  & 0
    \end{array}
    \]
    Para entrada $2$: $\overline{A}B\overline{C} = 1 \cdot 1 \cdot 1 = 1$ \\
    Para as outras entradas: há pelo menos um $0$ no produto (AND), o que faz com que o resultado fique $0$. \\
    Portanto: $m_2 = \overline{A}B\overline{C}$. 
   % \includegraphics[scale=0.2]{cap1/tabela_exemplo_2.png}
    \caption{Exemplo: $m=3$ bits e obtenção do minitermo $m_2$.}
    \end{figure}
    
   Dessa maneira, os minitermos $m_i$ e a função $f$ podem ser realizados com portas OR, AND e NOT.
 
 \end{proof}

 \begin{remark}
  Pelas leis DeMorgan, é possível escrever a porta OR em termos das portas NOT e AND 
  \[ x+y = \overline{\overline{x+y}} = \overline{\overline{x} \cdot \overline{y}} \]
  e é possível escrever a porta AND em termos das portas NOT e OR fazendo
  \[ x\cdot y = \overline{\overline{x\cdot y}} = \overline{\overline{x}+\overline{y}} \ . \]
  Dessa forma, pode-se excluir a porta OR ou a AND no teorema \ref{cap1:teorema_universalidade_or_and_not} e continua-se obtendo um conjunto de portas universal.
 \end{remark}

 
 \begin{theorem}[Universalidade da porta NAND]\label{cap1:teorema_universalidade_nand}
  \ 
  
   Uma função booleana $f \colon \{0,1\}^m \to \{0,1\}^n$ qualquer pode ser implementada por uma composição de portas lógicas NAND (além das portas SWAP e FANOUT).
 \end{theorem}
 
 \begin{proof}
  Pelo teorema \ref{cap1:teorema_universalidade_or_and_not}, qualquer função booleana $f$ pode ser implementada por portas lógicas OR, AND e NOT. Basta então mostrar que é possível obter as portas OR, AND e NOT a partir da porta NAND. Isso é possível, como se pode observar a seguir:
  
  \noindent Porta NOT:
  \[ \text{NOT}(A)  =  \overline{A} = \overline{A\cdot A} = \text{NAND}(A,A)\]
  
  \noindent Porta AND:
  \[ \text{AND}(A,B) = A \cdot B = \overline{\overline{A\cdot B}} = \text{NOT}\Big(\text{NAND}(A,B)\Big) \]
  
  \noindent Porta OR:
  \[ \text{OR}(A,B) = A + B = \overline{\overline{A+B}} = \overline{\overline{A} \cdot \overline{B}} = \text{NAND}\Big(\text{NOT}(A) , \text{NOT}(B) \Big) \]
  
  Como a porta NOT pode ser construída usando portas NAND, as portas AND e NOT, que utilizam NAND e NOT também podem ser construídas apenas com portas NAND.
  
  
 \end{proof}


 
\end{subsection}

\begin{subsection}{Somadores e Unidade Lógica/Aritmética}\label{cap1:somadores}
 
 Com portas lógicas é possível implementar diversos componentes que realizam funções mais complexas. Alguns exemplos são somadores, subtratores, comparadores de igualdade, entre outros. Nessa seção, o somador de $n$ bits é construído a partir de portas lógicas. Também é apresentada, a título de curiosidade, uma versão simplificada da Unidade Lógica/Aritmética, um dos principais componentes do bloco operativo de um processador. 
 %Muitos desses componentes possuem entradas de controle, que definem que tipo de operação será realizada ou não de acordo com os bits de controle recebidos. 
 
 \subsubsection*{Half Adder}
 
 O meio somador, também chamado \emph{half adder}, é um componente que realiza a soma de duas entradas $A$ e $B$, de 1 bit, e disponibiliza o resultado da soma na variável $S$, de 1 bit, e fornece um bit ``vai um'' (\emph{carry out}), denotado por $C_{\text{out}}$. A tabela verdade desejada para esse sistema é dada na figura \ref{cap1:fig_tab_verdade_half_adder}, apresentada a seguir.
 
\begin{figure}[H]
\centering
\includegraphics[scale=0.4]{cap1/half_adder_truth_table.png}
\caption{Tabela verdade do half adder. Fonte: \cite{book:ddca_harris}, p. 240}
\label{cap1:fig_tab_verdade_half_adder}
\end{figure}
 
 Pode-se perceber que as expressões booleanas para as saídas $S$ e $C_{\text{out}}$ são dadas pelas portas lógicas XOR e AND, respectivamente:
 \[ S = A \oplus B \ , \]
 \[ C_{\text{out}} = A \cdot B \ .\]
 Dessa forma, pode-se construir um circuito half adder de acordo com o esquemático da figura \ref{cap1:fig_circuito_half_adder}.
 
 \begin{figure}[H]
\centering
\includegraphics[scale=0.5]{cap1/half_adder_gates.png}
\caption{Uma realização do half adder.}
\label{cap1:fig_circuito_half_adder}
\end{figure}
 
 
 
 \subsubsection*{Full Adder}
 
 O somador completo de 1 bit, também chamado \emph{full adder}, é um componente que realiza a soma de duas entradas de 1 bit, $A$ e $B$. É interessante ter uma entrada \emph{carry in} ($C_{\text{in}}$), a ser somada com $A$ e $B$ para modelar o ``vai um'' que entra na casa binária em questão. A saída é o resultado da soma, $S$ e o ``vai um'' para a próxima casa binária é denotado por \emph{carry out} ($C_{\text{out}}$). A tabela verdade desejada para esse sistema é dada na figura \ref{cap1:fig_tab_verdade_full_adder}.
 
     \begin{figure}[H]
\centering
\includegraphics[scale=0.5]{cap1/full_adder_truth_table.png}
\caption{Tabela verdade do full adder. Fonte: \cite{book:ds_tocci}, p. 674}
\label{cap1:fig_tab_verdade_full_adder}
\end{figure}
 
 Para implementar o somador completo, podemos extrair as equações booleanas para as saídas $S$ e $C_{\text{out}}$ em função das entradas $A$, $B$ e $C_{\text{in}}$. Escrevendo as entradas como soma de minitermos (como feito no Teorema \ref{cap1:teorema_universalidade_or_and_not}), obtemos:
 \[
 \begin{split}
    S &= \overline{A}\, \overline{B} \, C_{\text{in}} + \overline{A}\,  B \, \overline{C_{\text{in}}} + A \, \overline{B}\, \overline{C_{\text{in}}} + A \, B \, C_{\text{in}} \\
    &= \overline{A} \Big( \overline{B} \, C_{\text{in}} + B \, \overline{C_{\text{in}}} \Big) + A \Big( \overline{B} \,\overline{C_{\text{in}}} + B \, C_{\text{in}} \Big) \\
    &= \overline{A} \Big( B \oplus C_{\text{in}} \Big) + A \Big( \overline{B \oplus C_{\text{in}}} \Big) \\
    &= A \oplus B \oplus C_{\text{in}} \ ,
 \end{split}
 \]
\[ 
 \begin{split}
  C_{\text{out}} &= \overline{A} \, B \,  C_{\text{in}} + A \, \overline{B} \,  C_{\text{in}} + A \, B\, \overline{ C_{\text{in}}} + A\, B\,  C_{\text{in}} \\
  &= \Big( \overline{A} \, B \,   + A \, \overline{B} \Big) C_{\text{in}} + A \, B \Big( C_{\text{in}}  + \overline{C_{\text{in}} } \Big) \\
  &= \big(A \oplus B\big)  C_{\text{in}} + A \, B  \ .\\
 \end{split} 
\]
 Portanto, pode-se implementar o full adder com o circuito da figura \ref{cap1:fig_circuito_full_adder}. Aproveita-se uma porta XOR no cálculo das duas expressões. 
 
 \begin{figure}[H]
\centering
\includegraphics[scale=0.4]{cap1/full_adder_gates.png}
\caption{Uma realização do full adder.}
\label{cap1:fig_circuito_full_adder}
\end{figure}
 
 \subsubsection*{Somador de $n$ bits}
  
 Com o full adder, é possível implementar um somador de $n$ bits. Esse componente realiza a soma de $n$ bits, interpretados como números inteiros sem sinal (da mesma forma que no teorema \ref{cap1:teorema_universalidade_or_and_not}) e disponibiliza o resultado da soma em $n$ bits e um bit carry out, que indica se houve \emph{overflow}, isto é, se a soma ultrapassou o valor máximo possível de ser representado pelos $n$ bits (que seria $2^n-1$ no caso de inteiros sem sinal). A figura abaixo mostra o símbolo para um somador de $n$ bits e uma implementação usando full adders.
 
  \begin{figure}[H]
\centering
\includegraphics[scale=0.5]{cap1/parallel_adder.png}
\caption{Símbolo para somador de $n$ bits. Implementação de um somador de $4$ bits usando 4 full adders. Fonte: \cite{book:ddca_harris}, p. 240}
\end{figure}
 
 Com algumas modificações, o somador de $n$ bits pode realizar subtrações também. Para tanto, as entradas devem ser interpretadas como inteiros com sinal. A representação de inteiros com sinal se dá por \emph{complemento de 2}. Essa representação não será abordada neste trabalho, podendo ser encontrada em mais detalhes nas referências \cite{book:ddca_harris}, p. 16-19, e \cite{book:ds_tocci}, p. 343-355.
 
  \subsubsection*{Unidade Lógica/Aritmética}
 
 Usando-se multiplexadores e demultiplexadores para direcionar os dados, é possível implementar sistemas que realizam diversas funções a depender de um conjunto de entradas de controle. Para fins de ilustração, segue o esquema de uma \emph{Unidade Lógica/Aritmética}, ou ALU (em inglês). Há diversas variações de ALUs que implementam mais ou menos funções lógicas/aritméticas. 
 
\begin{figure}[H]
\centering
\includegraphics[scale=0.6]{cap1/alu.png}
\caption{Esquema de uma ALU. Fonte: \cite{book:ddca_harris}, p. 248-249}
\end{figure}

A Unidade Lógica/Aritmética é um dos principais componentes do bloco operativo de um processador (\!\!\cite{book:ddca_harris}, p. 248).
 
\end{subsection}


\end{section}
